import { SUDOKU_SIZE, BOX_SIZE } from '@sudoku/constants';

// ==========================================
// 1. Context: Data Container & Basic Operations
// ==========================================
class SudokuContext {
    /**
     * @param {number[][]} grid - 9x9 Sudoku grid (0 represents empty)
     */
    constructor(grid) {
        this.grid = grid;
        this.candidatesMap = [];
        this._initCandidates();
    }

    _initCandidates() {
        // Initialize candidates: [] for filled cells, [1..9] for empty ones
        for (let r = 0; r < SUDOKU_SIZE; r++) {
            const row = [];
            for (let c = 0; c < SUDOKU_SIZE; c++) {
                row.push(this.grid[r][c] !== 0 ? [] : [1, 2, 3, 4, 5, 6, 7, 8, 9]);
            }
            this.candidatesMap.push(row);
        }

        // Initial elimination based on existing numbers in the grid
        for (let r = 0; r < SUDOKU_SIZE; r++) {
            for (let c = 0; c < SUDOKU_SIZE; c++) {
                if (this.grid[r][c] !== 0) {
                    this.removeCandidateFromRelated(r, c, this.grid[r][c]);
                }
            }
        }
    }

    /**
     * Removes a specific value from the candidates of related cells (Row, Col, Box).
     */
    removeCandidateFromRelated(r, c, val) {
        let changed = false;
        const remove = (arr, v) => {
            if (!arr) return false;
            const idx = arr.indexOf(v);
            if (idx !== -1) { arr.splice(idx, 1); return true; }
            return false;
        };

        // Remove from Row
        for (let i = 0; i < SUDOKU_SIZE; i++) {
            if (i !== c) if (remove(this.candidatesMap[r][i], val)) changed = true;
        }
        // Remove from Col
        for (let i = 0; i < SUDOKU_SIZE; i++) {
            if (i !== r) if (remove(this.candidatesMap[i][c], val)) changed = true;
        }
        // Remove from Box
        const startRow = Math.floor(r / BOX_SIZE) * BOX_SIZE;
        const startCol = Math.floor(c / BOX_SIZE) * BOX_SIZE;
        for (let i = startRow; i < startRow + BOX_SIZE; i++) {
            for (let j = startCol; j < startCol + BOX_SIZE; j++) {
                if (i !== r || j !== c) if (remove(this.candidatesMap[i][j], val)) changed = true;
            }
        }
        return changed;
    }

    getCandidates(r, c) { return this.candidatesMap[r][c]; }

    setCandidates(r, c, newCandidates) {
        if (this.candidatesMap[r][c].length !== newCandidates.length) {
            this.candidatesMap[r][c] = newCandidates;
            return true;
        }
        return false;
    }
}

// ==========================================
// 2. Strategy Base Class
// ==========================================
class Strategy {
    execute(context) { throw new Error("Implement execute()"); }
    
    getRowCells(row) { return Array.from({length:9}, (_, c) => [row, c]); }
    getColCells(col) { return Array.from({length:9}, (_, r) => [r, col]); }
    getBoxCells(boxIdx) {
        const cells = [];
        const startRow = Math.floor(boxIdx / BOX_SIZE) * BOX_SIZE;
        const startCol = (boxIdx % BOX_SIZE) * BOX_SIZE;
        for (let r = startRow; r < startRow + BOX_SIZE; r++)
            for (let c = startCol; c < startCol + BOX_SIZE; c++) cells.push([r, c]);
        return cells;
    }
}

// ==========================================
// 3. Concrete Strategies
// ==========================================

/**
 * Basic Strategy: If a cell has only one candidate, confirm it and remove it from peers.
 */
class NakedSinglePropagationStrategy extends Strategy {
    execute(context) {
        let changed = false;
        for (let r = 0; r < SUDOKU_SIZE; r++) {
            for (let c = 0; c < SUDOKU_SIZE; c++) {
                const cands = context.getCandidates(r, c);
                if (context.grid[r][c] === 0 && cands.length === 1) {
                    if (context.removeCandidateFromRelated(r, c, cands[0])) changed = true;
                }
            }
        }
        return changed;
    }
}

/**
 * Hidden Single: If a candidate appears only once in a unit (Row/Col/Box), 
 * the cell must be that value, even if it has other candidates.
 */
class HiddenSingleStrategy extends Strategy {
    execute(context) {
        let changed = false;
        const units = [{ getter: this.getRowCells }, { getter: this.getColCells }, { getter: this.getBoxCells }];
        for (const unitDef of units) {
            for (let i = 0; i < SUDOKU_SIZE; i++) {
                const cells = unitDef.getter(i);
                const counts = {};
                
                // Count candidate occurrences in the unit
                for (const [r, c] of cells) {
                    if (context.grid[r][c] === 0) {
                        for (const val of context.getCandidates(r, c)) {
                            if (!counts[val]) counts[val] = [];
                            counts[val].push([r, c]);
                        }
                    }
                }

                // If a value appears exactly once, set it as the only candidate
                for (const val in counts) {
                    if (counts[val].length === 1) {
                        const [tR, tC] = counts[val][0];
                        if (context.getCandidates(tR, tC).length > 1) {
                            context.setCandidates(tR, tC, [parseInt(val)]);
                            changed = true;
                        }
                    }
                }
            }
        }
        return changed;
    }
}

/**
 * Naked Pair: If two cells in a unit share the exact same two candidates,
 * remove these candidates from all other cells in that unit.
 */
class NakedPairStrategy extends Strategy {
    execute(context) {
        let changed = false;
        const units = [{ getter: this.getRowCells }, { getter: this.getColCells }, { getter: this.getBoxCells }];
        for (const unitDef of units) {
            for (let i = 0; i < SUDOKU_SIZE; i++) {
                const cells = unitDef.getter(i);
                const potential = cells.filter(([r, c]) => context.grid[r][c] === 0 && context.getCandidates(r, c).length === 2);
                
                for (let j = 0; j < potential.length; j++) {
                    for (let k = j + 1; k < potential.length; k++) {
                        const [r1, c1] = potential[j];
                        const [r2, c2] = potential[k];
                        const cands1 = context.getCandidates(r1, c1);
                        const cands2 = context.getCandidates(r2, c2);

                        // Check if candidates are identical
                        if (cands1[0] === cands2[0] && cands1[1] === cands2[1]) {
                            const [v1, v2] = cands1;
                            for (const [ur, uc] of cells) {
                                // Skip the pair itself or filled cells
                                if ((ur === r1 && uc === c1) || (ur === r2 && uc === c2)) continue;
                                if (context.grid[ur][uc] !== 0) continue;

                                // Remove pair values from other cells
                                const arr = context.getCandidates(ur, uc);
                                let mod = false;
                                if (arr.includes(v1)) { arr.splice(arr.indexOf(v1), 1); mod = true; }
                                if (arr.includes(v2)) { arr.splice(arr.indexOf(v2), 1); mod = true; }
                                if (mod) changed = true;
                            }
                        }
                    }
                }
            }
        }
        return changed;
    }
}

// --- 新增：隐性数对 (Hidden Pair) ---
// 逻辑：如果两个数字在某个区域内（行/列/宫）只出现在两个格子里，且这两个格子完全重合，
// 那么这两个格子只能是这两个数字，可以排除这两个格子里的其他候选数。
class HiddenPairStrategy extends Strategy {
    execute(context) {
        let changed = false;
        const units = [{ getter: this.getRowCells }, { getter: this.getColCells }, { getter: this.getBoxCells }];
        
        for (const unitDef of units) {
            for (let i = 0; i < SUDOKU_SIZE; i++) {
                const cells = unitDef.getter(i);
                const counts = {}; // Map<number, Array<[r,c]>>

                // 1. 统计每个数字出现的位置
                for (const [r, c] of cells) {
                    if (context.grid[r][c] === 0) {
                        for (const val of context.getCandidates(r, c)) {
                            if (!counts[val]) counts[val] = [];
                            counts[val].push(`${r},${c}`);
                        }
                    }
                }

                // 2. 寻找只出现了2次的数字
                const candidatesAppearingTwice = [];
                for (const val in counts) {
                    if (counts[val].length === 2) {
                        candidatesAppearingTwice.push({ val: parseInt(val), positions: counts[val] });
                    }
                }

                // 3. 寻找位置完全重合的两个数字
                for (let j = 0; j < candidatesAppearingTwice.length; j++) {
                    for (let k = j + 1; k < candidatesAppearingTwice.length; k++) {
                        const cand1 = candidatesAppearingTwice[j];
                        const cand2 = candidatesAppearingTwice[k];

                        // 检查位置是否相同
                        if (cand1.positions[0] === cand2.positions[0] && 
                            cand1.positions[1] === cand2.positions[1]) {
                            
                            // 找到隐性数对！
                            const pos1 = cand1.positions[0].split(',').map(Number);
                            const pos2 = cand1.positions[1].split(',').map(Number);
                            const pairValues = [cand1.val, cand2.val];

                            // 执行排除：在这两个格子里，保留 Pair，删除其他
                            for (const [r, c] of [pos1, pos2]) {
                                const currentCands = context.getCandidates(r, c);
                                if (currentCands.length > 2) {
                                    // 只有当还有其他杂质时才清理
                                    const newCands = currentCands.filter(v => pairValues.includes(v));
                                    if (newCands.length !== currentCands.length) {
                                        context.setCandidates(r, c, newCands);
                                        changed = true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return changed;
    }
}


// ==========================================
// 4. Strategy Factory
// ==========================================
class StrategyFactory {
    constructor() {
        this.strategies = new Map();
    }

    register(name, strategy) {
        this.strategies.set(name, strategy);
    }

    getStrategy(name) {
        return this.strategies.get(name);
    }
}

// Initialize factory and register strategies
const strategyFactory = new StrategyFactory();
strategyFactory.register('NakedSingle', new NakedSinglePropagationStrategy());
strategyFactory.register('HiddenSingle', new HiddenSingleStrategy());
strategyFactory.register('NakedPair', new NakedPairStrategy());
strategyFactory.register('HiddenPair', new HiddenPairStrategy());
// Basic propagation strategy used in every loop
const PROPAGATION = strategyFactory.getStrategy('NakedSingle');

// ==========================================
// 5. Public APIs
// ==========================================

/**
 * Calculates the full set of candidates for the grid based on selected strategies.
 * @param {number[][]} grid - 9x9 current grid
 * @param {string[]} strategiesToUse - List of strategy names to apply
 * @returns {number[][][]} Matrix of candidate arrays
 */
export function getCandidateSet(grid, strategiesToUse = []) {
    const context = new SudokuContext(grid);
    const activeStrategies = strategiesToUse
        .map(name => strategyFactory.getStrategy(name))
        .filter(s => s);

    let changed = true;
    while (changed) {
        changed = false;
        // Always run basic propagation first
        if (PROPAGATION.execute(context)) { changed = true; continue; }
        
        // Run advanced strategies
        for (const s of activeStrategies) {
            if (s.execute(context)) { changed = true; break; }
        }
    }
    return context.candidatesMap;
}

/**
 * Validates the grid for hard conflicts and dead ends.
 * @param {number[][]} grid
 * @returns {{isValid: boolean, conflicts: Array}}
 */
export function validateGrid(grid) {
    const context = new SudokuContext(grid);
    const conflicts = [];
    let isValid = true;

    // 1. Check Hard Rules (Duplicates in Row/Col)
    const checkGroup = (arr, type, idx) => {
        const seen = {};
        arr.forEach((val, i) => {
            if (val !== 0) {
                if (seen[val]) {
                    isValid = false;
                    if (type === 'row') conflicts.push([idx, i]);
                }
                seen[val] = true;
            }
        });
    };

    for (let i = 0; i < SUDOKU_SIZE; i++) {
        checkGroup(grid[i], 'row', i);
        checkGroup(grid.map(r => r[i]), 'col', i);
    }

    // 2. Check Dead Ends (Empty cells with 0 candidates)
    // Must run basic propagation to get accurate candidates
    PROPAGATION.execute(context);
    
    for(let r = 0; r < SUDOKU_SIZE; r++) {
        for(let c = 0; c < SUDOKU_SIZE; c++) {
            if (grid[r][c] === 0 && context.getCandidates(r, c).length === 0) {
                isValid = false;
                conflicts.push([r, c]);
            }
        }
    }
    
    return { isValid, conflicts };
}


export const DIFFICULTY_STRATEGIES = {
    // Very Easy: 全力辅助。开启所有策略 (包括高级的 HiddenPair)，
    // 系统会自动剔除所有可能的干扰项，候选数最少，最容易解。
    veryeasy: ['HiddenSingle', 'NakedPair', 'HiddenPair'], 
    
    // Easy: 强力辅助。开启显性数对，剔除大部分干扰。
    easy:     ['HiddenSingle', 'NakedPair'], 
    
    // Medium: 中等辅助。仅开启隐性唯一。
    medium:   ['HiddenSingle'],
    
    // Hard: 弱辅助。仅使用最基础的排除法 (Naked Single，基础循环自带)，
    // 不提供任何高级策略削减，候选数最多，最难判断。
    hard:     [] 
};

/**
 * 根据难度字符串获取对应的策略数组
 * @param {string} difficulty - 'veryeasy' | 'easy' | 'medium' | 'hard'
 * @returns {string[]} 策略名称数组
 */
export function getStrategiesByDifficulty(difficulty) {
    return DIFFICULTY_STRATEGIES[difficulty] || DIFFICULTY_STRATEGIES['medium'];
}