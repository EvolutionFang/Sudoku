import { SUDOKU_SIZE, BOX_SIZE } from '@sudoku/constants';

// ==========================================
// 1. 上下文类：数据容器与基础操作
// ==========================================
// ==========================================
// 1. 上下文类：管理数据与基础操作 (Context)
// ==========================================
class SudokuContext {
    /**
     * @param {number[][]} grid - 9x9 棋盘数组 (0代表空)
     */
    constructor(grid) {
        this.grid = grid;
        // 1. 先初始化为空数组，防止后续调用报错
        this.candidatesMap = []; 
        // 2. 执行初始化逻辑
        this._initCandidates();
    }

    /**
     * 初始化基础候选数
     */
    _initCandidates() {
        // 第一步：构建基础的 1-9 候选数映射
        for (let r = 0; r < SUDOKU_SIZE; r++) {
            const row = [];
            for (let c = 0; c < SUDOKU_SIZE; c++) {
                // 如果格子已有数字，候选数为空；否则为 [1..9]
                row.push(this.grid[r][c] !== 0 ? [] : [1, 2, 3, 4, 5, 6, 7, 8, 9]);
            }
            this.candidatesMap.push(row);
        }

        // 第二步：根据现有数字进行剔除 (基础规则)
        // 此时 this.candidatesMap 已经有值了，调用 removeCandidateFromRelated 不会报错
        for (let r = 0; r < SUDOKU_SIZE; r++) {
            for (let c = 0; c < SUDOKU_SIZE; c++) {
                if (this.grid[r][c] !== 0) {
                    this.removeCandidateFromRelated(r, c, this.grid[r][c]);
                }
            }
        }
    }

    /**
     * 从指定位置的相关区域（行、列、宫）移除特定候选数
     */
    removeCandidateFromRelated(r, c, val) {
        let changed = false;
        const remove = (arr, v) => {
            if (!arr) return false; // 安全检查
            const idx = arr.indexOf(v);
            if (idx !== -1) { arr.splice(idx, 1); return true; }
            return false;
        };

        // 移除同行
        for (let i = 0; i < SUDOKU_SIZE; i++) {
            if (i !== c) if (remove(this.candidatesMap[r][i], val)) changed = true;
        }
        // 移除同列
        for (let i = 0; i < SUDOKU_SIZE; i++) {
            if (i !== r) if (remove(this.candidatesMap[i][c], val)) changed = true;
        }
        // 移除同宫
        const startRow = Math.floor(r / BOX_SIZE) * BOX_SIZE;
        const startCol = Math.floor(c / BOX_SIZE) * BOX_SIZE;
        for (let i = startRow; i < startRow + BOX_SIZE; i++) {
            for (let j = startCol; j < startCol + BOX_SIZE; j++) {
                if (i !== r || j !== c) if (remove(this.candidatesMap[i][j], val)) changed = true;
            }
        }
        return changed;
    }

    getCandidates(r, c) { return this.candidatesMap[r][c]; }

    setCandidates(r, c, newCandidates) {
        if (this.candidatesMap[r][c].length !== newCandidates.length) {
            this.candidatesMap[r][c] = newCandidates;
            return true;
        }
        return false;
    }
}

// ==========================================
// 2. 策略基类
// ==========================================
class Strategy {
    execute(context) { throw new Error("Implement execute()"); }
    getRowCells(row) { return Array.from({length:9}, (_, c) => [row, c]); }
    getColCells(col) { return Array.from({length:9}, (_, r) => [r, col]); }
    getBoxCells(boxIdx) {
        const cells = [];
        const startRow = Math.floor(boxIdx / BOX_SIZE) * BOX_SIZE;
        const startCol = (boxIdx % BOX_SIZE) * BOX_SIZE;
        for (let r = startRow; r < startRow + BOX_SIZE; r++)
            for (let c = startCol; c < startCol + BOX_SIZE; c++) cells.push([r, c]);
        return cells;
    }
}

// ==========================================
// 3. 具体策略实现
// ==========================================
class NakedSinglePropagationStrategy extends Strategy {
    execute(context) {
        let changed = false;
        for (let r = 0; r < SUDOKU_SIZE; r++) {
            for (let c = 0; c < SUDOKU_SIZE; c++) {
                const cands = context.getCandidates(r, c);
                if (context.grid[r][c] === 0 && cands.length === 1) {
                    if (context.removeCandidateFromRelated(r, c, cands[0])) changed = true;
                }
            }
        }
        return changed;
    }
}

class HiddenSingleStrategy extends Strategy {
    execute(context) {
        let changed = false;
        const units = [{ getter: this.getRowCells }, { getter: this.getColCells }, { getter: this.getBoxCells }];
        for (const unitDef of units) {
            for (let i = 0; i < SUDOKU_SIZE; i++) {
                const cells = unitDef.getter(i);
                const counts = {};
                for (const [r, c] of cells) {
                    if (context.grid[r][c] === 0) {
                        for (const val of context.getCandidates(r, c)) {
                            if (!counts[val]) counts[val] = [];
                            counts[val].push([r, c]);
                        }
                    }
                }
                for (const val in counts) {
                    if (counts[val].length === 1) {
                        const [tR, tC] = counts[val][0];
                        if (context.getCandidates(tR, tC).length > 1) {
                            context.setCandidates(tR, tC, [parseInt(val)]);
                            changed = true;
                        }
                    }
                }
            }
        }
        return changed;
    }
}

class NakedPairStrategy extends Strategy {
    execute(context) {
        let changed = false;
        const units = [{ getter: this.getRowCells }, { getter: this.getColCells }, { getter: this.getBoxCells }];
        for (const unitDef of units) {
            for (let i = 0; i < SUDOKU_SIZE; i++) {
                const cells = unitDef.getter(i);
                const potential = cells.filter(([r, c]) => context.grid[r][c] === 0 && context.getCandidates(r, c).length === 2);
                for (let j = 0; j < potential.length; j++) {
                    for (let k = j + 1; k < potential.length; k++) {
                        const [r1, c1] = potential[j];
                        const [r2, c2] = potential[k];
                        const cands1 = context.getCandidates(r1, c1);
                        const cands2 = context.getCandidates(r2, c2);
                        if (cands1[0] === cands2[0] && cands1[1] === cands2[1]) {
                            const [v1, v2] = cands1;
                            for (const [ur, uc] of cells) {
                                if ((ur === r1 && uc === c1) || (ur === r2 && uc === c2)) continue;
                                if (context.grid[ur][uc] !== 0) continue;
                                const arr = context.getCandidates(ur, uc);
                                let mod = false;
                                if (arr.includes(v1)) { arr.splice(arr.indexOf(v1), 1); mod = true; }
                                if (arr.includes(v2)) { arr.splice(arr.indexOf(v2), 1); mod = true; }
                                if (mod) changed = true;
                            }
                        }
                    }
                }
            }
        }
        return changed;
    }
}

// ==========================================
// 4. 核心接口导出
// ==========================================
const STRATEGIES = {
    'NakedSingle': new NakedSinglePropagationStrategy(),
    'HiddenSingle': new HiddenSingleStrategy(),
    'NakedPair': new NakedPairStrategy()
};
const PROPAGATION = STRATEGIES['NakedSingle'];

/**
 * 接口1: 获取全盘候选数集合 (Core Calculation)
 * @param {number[][]} grid - 9x9 当前棋盘
 * @param {string[]} strategiesToUse - 启用的策略列表
 * @returns {number[][][]} 每个格子的候选数数组
 */
export function getCandidateSet(grid, strategiesToUse = []) {
    const context = new SudokuContext(grid);
    const activeStrategies = strategiesToUse.map(name => STRATEGIES[name]).filter(s => s);

    let changed = true;
    while (changed) {
        changed = false;
        if (PROPAGATION.execute(context)) { changed = true; continue; }
        for (const s of activeStrategies) {
            if (s.execute(context)) { changed = true; break; }
        }
    }
    return context.candidatesMap;
}

/**
 * 接口2: 状态合法性校验 (Validation)
 * 供回溯使用，判断当前状态是否非法或死局
 * @param {number[][]} grid
 * @returns {{isValid: boolean, conflicts: Array}}
 */
export function validateState(grid) {
    const context = new SudokuContext(grid);
    const conflicts = [];
    let isValid = true;

    // 1. 检查硬规则 (行列宫重复)
    const checkGroup = (arr, type, idx) => {
        const seen = {};
        arr.forEach((val, i) => {
            if (val !== 0) {
                if (seen[val]) {
                    isValid = false;
                    if (type === 'row') conflicts.push([idx, i]);
                }
                seen[val] = true;
            }
        });
    };
    for (let i = 0; i < SUDOKU_SIZE; i++) {
        checkGroup(grid[i], 'row', i);
        checkGroup(grid.map(r => r[i]), 'col', i);
    }
    // (宫检查简化省略，通常行列检查足以发现大部分填写错误)

    // 2. 检查死局 (空格子但无候选数)
    // 必须跑一次基础传播以获取准确的候选数
    PROPAGATION.execute(context);
    
    for(let r=0; r<SUDOKU_SIZE; r++) {
        for(let c=0; c<SUDOKU_SIZE; c++) {
            if (grid[r][c] === 0 && context.getCandidates(r, c).length === 0) {
                isValid = false;
                conflicts.push([r, c]);
            }
        }
    }
    
    return { isValid, conflicts };
}