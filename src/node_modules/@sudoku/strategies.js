import { SUDOKU_SIZE, BOX_SIZE } from '@sudoku/constants';

// ==========================================
// 1. Context: Data Container & Basic Operations
// ==========================================
class SudokuContext {
    /**
     * @param {number[][]} grid - 9x9 Sudoku grid (0 represents empty)
     */
    constructor(grid) {
        this.grid = grid;
        this.candidatesMap = [];
        this._initCandidates();
    }

    _initCandidates() {
        // Initialize candidates: [] for filled cells, [1..9] for empty ones
        for (let r = 0; r < SUDOKU_SIZE; r++) {
            const row = [];
            for (let c = 0; c < SUDOKU_SIZE; c++) {
                row.push(this.grid[r][c] !== 0 ? [] : [1, 2, 3, 4, 5, 6, 7, 8, 9]);
            }
            this.candidatesMap.push(row);
        }

        // Initial elimination based on existing numbers in the grid
        for (let r = 0; r < SUDOKU_SIZE; r++) {
            for (let c = 0; c < SUDOKU_SIZE; c++) {
                if (this.grid[r][c] !== 0) {
                    this.removeCandidateFromRelated(r, c, this.grid[r][c]);
                }
            }
        }
    }

    /**
     * Removes a specific value from the candidates of related cells (Row, Col, Box).
     * @returns {boolean} True if any candidate was removed
     */
    removeCandidateFromRelated(r, c, val) {
        let changed = false;
        const remove = (arr, v) => {
            if (!arr) return false;
            const idx = arr.indexOf(v);
            if (idx !== -1) { arr.splice(idx, 1); return true; }
            return false;
        };

        // Remove from Row
        for (let i = 0; i < SUDOKU_SIZE; i++) {
            if (i !== c) if (remove(this.candidatesMap[r][i], val)) changed = true;
        }
        // Remove from Col
        for (let i = 0; i < SUDOKU_SIZE; i++) {
            if (i !== r) if (remove(this.candidatesMap[i][c], val)) changed = true;
        }
        // Remove from Box
        const startRow = Math.floor(r / BOX_SIZE) * BOX_SIZE;
        const startCol = Math.floor(c / BOX_SIZE) * BOX_SIZE;
        for (let i = startRow; i < startRow + BOX_SIZE; i++) {
            for (let j = startCol; j < startCol + BOX_SIZE; j++) {
                if (i !== r || j !== c) if (remove(this.candidatesMap[i][j], val)) changed = true;
            }
        }
        return changed;
    }

    getCandidates(r, c) { return this.candidatesMap[r][c]; }

    setCandidates(r, c, newCandidates) {
        if (this.candidatesMap[r][c].length !== newCandidates.length) {
            this.candidatesMap[r][c] = newCandidates;
            return true;
        }
        return false;
    }
}

// ==========================================
// 2. Strategy Base Class
// ==========================================
class Strategy {
    /**
     * Executes the strategy logic.
     * @param {SudokuContext} context 
     * @returns {boolean} True if the grid or candidates were modified
     */
    execute(context) { throw new Error("Implement execute()"); }
    
    getRowCells(row) { return Array.from({length:9}, (_, c) => [row, c]); }
    getColCells(col) { return Array.from({length:9}, (_, r) => [r, col]); }
    getBoxCells(boxIdx) {
        const cells = [];
        const startRow = Math.floor(boxIdx / BOX_SIZE) * BOX_SIZE;
        const startCol = (boxIdx % BOX_SIZE) * BOX_SIZE;
        for (let r = startRow; r < startRow + BOX_SIZE; r++)
            for (let c = startCol; c < startCol + BOX_SIZE; c++) cells.push([r, c]);
        return cells;
    }
}

// ==========================================
// 3. Concrete Strategies
// ==========================================

/**
 * Basic Strategy: If a cell has only one candidate, confirm it and remove it from peers.
 * Also known as "Naked Single".
 */
class NakedSinglePropagationStrategy extends Strategy {
    execute(context) {
        let changed = false;
        for (let r = 0; r < SUDOKU_SIZE; r++) {
            for (let c = 0; c < SUDOKU_SIZE; c++) {
                const cands = context.getCandidates(r, c);
                if (context.grid[r][c] === 0 && cands.length === 1) {
                    if (context.removeCandidateFromRelated(r, c, cands[0])) changed = true;
                }
            }
        }
        return changed;
    }
}

/**
 * Hidden Single: If a candidate appears only once in a unit (Row/Col/Box), 
 * the cell must be that value, even if it has other candidates.
 */
class HiddenSingleStrategy extends Strategy {
    execute(context) {
        let changed = false;
        const units = [{ getter: this.getRowCells }, { getter: this.getColCells }, { getter: this.getBoxCells }];
        for (const unitDef of units) {
            for (let i = 0; i < SUDOKU_SIZE; i++) {
                const cells = unitDef.getter(i);
                const counts = {};
                
                // Count candidate occurrences in the unit
                for (const [r, c] of cells) {
                    if (context.grid[r][c] === 0) {
                        for (const val of context.getCandidates(r, c)) {
                            if (!counts[val]) counts[val] = [];
                            counts[val].push([r, c]);
                        }
                    }
                }

                // If a value appears exactly once, set it as the only candidate
                for (const val in counts) {
                    if (counts[val].length === 1) {
                        const [tR, tC] = counts[val][0];
                        if (context.getCandidates(tR, tC).length > 1) {
                            context.setCandidates(tR, tC, [parseInt(val)]);
                            changed = true;
                        }
                    }
                }
            }
        }
        return changed;
    }
}

/**
 * Naked Pair: If two cells in a unit share the exact same two candidates,
 * remove these candidates from all other cells in that unit.
 */
class NakedPairStrategy extends Strategy {
    execute(context) {
        let changed = false;
        const units = [{ getter: this.getRowCells }, { getter: this.getColCells }, { getter: this.getBoxCells }];
        for (const unitDef of units) {
            for (let i = 0; i < SUDOKU_SIZE; i++) {
                const cells = unitDef.getter(i);
                const potential = cells.filter(([r, c]) => context.grid[r][c] === 0 && context.getCandidates(r, c).length === 2);
                
                for (let j = 0; j < potential.length; j++) {
                    for (let k = j + 1; k < potential.length; k++) {
                        const [r1, c1] = potential[j];
                        const [r2, c2] = potential[k];
                        const cands1 = context.getCandidates(r1, c1);
                        const cands2 = context.getCandidates(r2, c2);

                        // Check if candidates are identical
                        if (cands1[0] === cands2[0] && cands1[1] === cands2[1]) {
                            const [v1, v2] = cands1;
                            for (const [ur, uc] of cells) {
                                // Skip the pair itself or filled cells
                                if ((ur === r1 && uc === c1) || (ur === r2 && uc === c2)) continue;
                                if (context.grid[ur][uc] !== 0) continue;

                                // Remove pair values from other cells
                                const arr = context.getCandidates(ur, uc);
                                let mod = false;
                                if (arr.includes(v1)) { arr.splice(arr.indexOf(v1), 1); mod = true; }
                                if (arr.includes(v2)) { arr.splice(arr.indexOf(v2), 1); mod = true; }
                                if (mod) changed = true;
                            }
                        }
                    }
                }
            }
        }
        return changed;
    }
}

// ==========================================
// 4. Strategy Factory
// ==========================================
class StrategyFactory {
    constructor() {
        this.strategies = new Map();
    }

    register(name, strategy) {
        this.strategies.set(name, strategy);
    }

    getStrategy(name) {
        return this.strategies.get(name);
    }
}

// Initialize factory and register strategies
const strategyFactory = new StrategyFactory();
strategyFactory.register('NakedSingle', new NakedSinglePropagationStrategy());
strategyFactory.register('HiddenSingle', new HiddenSingleStrategy());
strategyFactory.register('NakedPair', new NakedPairStrategy());

// Basic propagation strategy used in every loop
const PROPAGATION = strategyFactory.getStrategy('NakedSingle');

// ==========================================
// 5. Recommendation Engine
// ==========================================

/**
 * Encapsulates the logic for evaluating and recommending the best strategy.
 * Implements a simulation-based scoring system.
 */
class RecommendationEngine {
    constructor(factory) {
        this.factory = factory;
        // difficultyCost acts as a tie-breaker for user cognitive load.
        // It should be small (< 1) so effective strategies are not penalized too heavily.
        this.strategiesProfile = [
            { 
                name: 'NakedSingle', 
                label: 'Naked Single',
                difficultyCost: 0, 
                reason: 'Only one candidate remains in the cell. This is the most direct solution.' 
            },
            { 
                name: 'HiddenSingle', 
                label: 'Hidden Single',
                difficultyCost: 0.1, 
                reason: 'A number has only one possible position in a row, column, or box.' 
            },
            { 
                name: 'NakedPair', 
                label: 'Naked Pair',
                difficultyCost: 0.2, 
                reason: 'A naked pair was found, simplifying candidates in related cells.' 
            }
        ];
    }

    /**
     * Counts the total number of candidates remaining in the grid.
     */
    _countTotalCandidates(context) {
        let count = 0;
        for (let r = 0; r < SUDOKU_SIZE; r++) {
            for (let c = 0; c < SUDOKU_SIZE; c++) {
                if (context.grid[r][c] === 0) {
                    count += context.getCandidates(r, c).length;
                }
            }
        }
        return count;
    }

    /**
     * Counts the total number of filled cells in the grid.
     */
    _countFilledCells(context) {
        let count = 0;
        for (let r = 0; r < SUDOKU_SIZE; r++) {
            for (let c = 0; c < SUDOKU_SIZE; c++) {
                if (context.grid[r][c] !== 0) count++;
            }
        }
        return count;
    }

    /**
     * Analyzes the grid and returns the best strategy recommendation.
     * @param {number[][]} grid 
     * @returns {Object|null} Recommendation object or null
     */
    recommend(grid) {
        const candidates = [];
        
        // Base metrics from the initial state
        const initialContext = new SudokuContext(grid);
        const initialFilled = this._countFilledCells(initialContext);
        const initialCandidatesCount = this._countTotalCandidates(initialContext);

        for (const profile of this.strategiesProfile) {
            // Use a fresh context for each simulation to ensure isolation
            const simContext = new SudokuContext(grid); 
            const strategyInstance = this.factory.getStrategy(profile.name);

            if (!strategyInstance) continue;

            const isEffective = strategyInstance.execute(simContext);

            if (isEffective) {
                const currentFilled = this._countFilledCells(simContext);
                const currentCandidatesCount = this._countTotalCandidates(simContext);
                
                const filledDiff = currentFilled - initialFilled;
                const removedDiff = initialCandidatesCount - currentCandidatesCount;

                // Scoring Formula: 
                // Prioritize filling cells (High Value) > Removing candidates (Medium Value) > Simplicity (Tie-breaker)
                // Cost is < 1 to ensure any progress (removedDiff >= 1) results in a positive score.
                let score = (filledDiff * 100) + (removedDiff * 1) - profile.difficultyCost;

                candidates.push({
                    strategy: profile.name,
                    reason: profile.reason,
                    details: { filled: filledDiff, removed: removedDiff },
                    score: score,
                    profile: profile
                });
            }
        }

        if (candidates.length === 0) return null;

        candidates.sort((a, b) => b.score - a.score);
        const bestChoice = candidates[0];

        // Generate dynamic reason
        let dynamicReason = bestChoice.reason;
        if (bestChoice.details.filled > 0) {
            dynamicReason += ` (Solves ${bestChoice.details.filled} cell(s) directly)`;
        } else if (bestChoice.details.removed > 0) {
            dynamicReason += ` (Eliminates ${bestChoice.details.removed} candidate(s), progressing the puzzle)`;
        }

        return {
            strategy: bestChoice.strategy,
            reason: dynamicReason
        };
    }
}

const recommender = new RecommendationEngine(strategyFactory);

// ==========================================
// 6. Public APIs
// ==========================================

/**
 * Calculates the full set of candidates for the grid based on selected strategies.
 * @param {number[][]} grid - 9x9 current grid
 * @param {string[]} strategiesToUse - List of strategy names to apply
 * @returns {number[][][]} Matrix of candidate arrays
 */
export function getCandidateSet(grid, strategiesToUse = []) {
    const context = new SudokuContext(grid);
    const activeStrategies = strategiesToUse
        .map(name => strategyFactory.getStrategy(name))
        .filter(s => s);

    let changed = true;
    while (changed) {
        changed = false;
        // Always run basic propagation first
        if (PROPAGATION.execute(context)) { changed = true; continue; }
        
        // Run advanced strategies
        for (const s of activeStrategies) {
            if (s.execute(context)) { changed = true; break; }
        }
    }
    return context.candidatesMap;
}

/**
 * Validates the grid for hard conflicts and dead ends.
 * @param {number[][]} grid
 * @returns {{isValid: boolean, conflicts: Array}}
 */
export function validateGrid(grid) {
    const context = new SudokuContext(grid);
    const conflicts = [];
    let isValid = true;

    // 1. Check Hard Rules (Duplicates in Row/Col)
    const checkGroup = (arr, type, idx) => {
        const seen = {};
        arr.forEach((val, i) => {
            if (val !== 0) {
                if (seen[val]) {
                    isValid = false;
                    if (type === 'row') conflicts.push([idx, i]);
                }
                seen[val] = true;
            }
        });
    };

    for (let i = 0; i < SUDOKU_SIZE; i++) {
        checkGroup(grid[i], 'row', i);
        checkGroup(grid.map(r => r[i]), 'col', i);
    }

    // 2. Check Dead Ends (Empty cells with 0 candidates)
    PROPAGATION.execute(context);
    
    for(let r = 0; r < SUDOKU_SIZE; r++) {
        for(let c = 0; c < SUDOKU_SIZE; c++) {
            if (grid[r][c] === 0 && context.getCandidates(r, c).length === 0) {
                isValid = false;
                conflicts.push([r, c]);
            }
        }
    }
    
    return { isValid, conflicts };
}

/**
 * Intelligent Recommendation API
 * Delegates logic to the RecommendationEngine to maintain clean architecture.
 * @param {number[][]} grid 
 * @returns {Object|null}
 */
export function getRecommendedStrategy(grid) {
    return recommender.recommend(grid);
}