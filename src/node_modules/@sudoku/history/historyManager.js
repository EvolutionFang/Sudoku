import { get } from 'svelte/store';
import { grid, userGrid } from '@sudoku/stores/grid';
import { cursor } from '@sudoku/stores/cursor';
import { candidates } from '@sudoku/stores/candidates';
import { notes } from '@sudoku/stores/notes';

export class ExplorationNode {
  constructor(state, parent = null, backtrackable = false, infos = null) {
    this.id = Date.now().toString(36) + Math.random().toString(36).substr(2);
    this.state = state;
    this.parent = parent;
    this.children = [];
    this.backtrackable = backtrackable;
    this.infos = infos; // {cell: {x,y}, candidates: [], tried: []}
    this.createdAt = Date.now();
  }
}

export class TreeHistoryManager {
  constructor(maxHistory = 100) {
    this.root = null;
    this.currentNode = null;
    this.MAX_HISTORY = maxHistory;
    this.isTracking = true;
    this.nodeCount = 0;

    this.undoStack = [];    
    this.redoStack = [];
  }
  
  createSnapshot(description = '') {
    return {
      board: JSON.parse(JSON.stringify(get(userGrid))),
      cursor: { ...get(cursor) },
      candidates: JSON.parse(JSON.stringify(get(candidates))),
      notes: get(notes),
      timestamp: Date.now(),
      description
    };
  }
  
  initGame(description = '游戏开始') {
    const snapshot = this.createSnapshot(description);
    this.root = new ExplorationNode(snapshot, null, false, null);
    this.currentNode = this.root;
    this.nodeCount = 1;

    this.undoStack.push(this.root);
    this.redoStack = [];

    this.printCurrentBoard();
    return this.root;
  }
  
  saveState(description = '', backtrackable = false, infos = null) {
    if (!this.isTracking || !this.currentNode) return null;
    
    const snapshot = this.createSnapshot(description);
    const newNode = new ExplorationNode(snapshot, this.currentNode, backtrackable, infos);
    
    this.currentNode.children.push(newNode);
    this.currentNode = newNode;
    this.nodeCount++;

    this.undoStack.push(newNode);
    this.redoStack = [];
    
    this.pruneHistory();

    this.printCurrentBoard();
    
    return newNode;
  }
  
  backtrack() {
    console.log('Attempting to backtrack...');
    console.log('Current Node ID:', this.currentNode ? this.currentNode.id : 'None');
    
    const backtrackNode = this.findLastBacktrackableNode();
    console.log('Backtrack Node ID:', backtrackNode ? backtrackNode.id : 'None');
    
    if (!backtrackNode) {
      console.log('没有可回溯的节点');
      return false;
    }
    
    const clearedState = this.createClearedState(backtrackNode.state, backtrackNode);
    
    backtrackNode.state = clearedState;
    
    this.currentNode = backtrackNode;

    const currentIndex = this.undoStack.findIndex(node => node === this.currentNode);
    if (currentIndex !== -1) {
      this.undoStack = this.undoStack.slice(0, currentIndex + 1);
    } else {
      this.undoStack.push(backtrackNode);
    }
    
    this.redoStack = [];
    
    // 应用清空后的状态
    this.printCurrentBoard("回溯后");
    
    console.log('已回溯到节点，等待用户重新选择');
    return true;
  }
  
  undo() {
    console.log('执行撤销...');
    
    if (this.undoStack.length === 0) {
      console.log('没有可撤销的操作');
      return false;
    }
    
    const currentState = this.undoStack.pop();
    
    this.redoStack.push(currentState);
    
    let previousState = null;
    if (this.undoStack.length > 0) {
      previousState = this.undoStack[this.undoStack.length - 1];
    } else if (currentState.parent) {
      previousState = currentState.parent;
      this.undoStack.push(previousState); 
    } else {
      previousState = this.root;
      this.undoStack.push(previousState);
    }
    
    this.currentNode = previousState;
    
    // 应用撤销后的状态
    this.printCurrentBoard("撤销后");
    
    console.log(`撤销到: ${previousState.state.description}`);
    return true;
  }
  
  redo() {
    console.log('执行重做...');
    
    if (this.redoStack.length === 0) {
      console.log('没有可重做的操作');
      return false;
    }
    
    const nextState = this.redoStack.pop();
    
    this.undoStack.push(nextState);
    
    this.currentNode = nextState;
    
    // 应用下一个状态
    this.printCurrentBoard("重做后");
    
    console.log(`重做到: ${nextState.state.description}`);
    return true;
  }

  findLastBacktrackableNode() {
    let node = this.currentNode;
    
    while (node) {
      if (node.backtrackable && node.infos) {
        if (node.infos.tried.length < node.infos.candidates.length) {
          return node;
        }
      }
      node = node.parent;
    }
    
    return null;
  }

  createClearedState(originalState, backtrackNode) {
    const newState = JSON.parse(JSON.stringify(originalState));
    
    if (backtrackNode.infos && backtrackNode.infos.cell) {
      const { x, y } = backtrackNode.infos.cell;
      
      newState.board[y][x] = 0;
      
      newState.cursor = { x, y };
      
      const key = `${x},${y}`;
      if (newState.candidates && newState.candidates[key]) {
        delete newState.candidates[key];
      }
    }
    
    newState.timestamp = Date.now();
    newState.description = `回溯: 等待重新选择 (${backtrackNode.infos?.cell?.x}, ${backtrackNode.infos?.cell?.y})`;
    
    return newState;
  }

  //-------------------------
  getCurrentNode() {
    return this.currentNode;
  }

  getInfos() {
    const backtrackNode = this.findLastBacktrackableNode();
    
    if (!backtrackNode || !backtrackNode.infos) {
      return {
        available: false,
        message: '没有可回溯的节点'
      };
    }
    
    const remaining = backtrackNode.infos.candidates.length - 
                      backtrackNode.infos.tried.length;
    
    return {
      available: true,
      node: backtrackNode,
      remainingCandidates: remaining,
      tried: backtrackNode.infos.tried,
      allCandidates: backtrackNode.infos.candidates,
      cell: backtrackNode.infos.cell
    };
  }
  
  get stats() {
    const backtrackNode = this.findLastBacktrackableNode();
    const hasValidBacktrackNode = backtrackNode && 
                                  backtrackNode.infos && 
                                  backtrackNode.infos.tried.length < backtrackNode.infos.candidates.length;
                             
    return {
      canUndo: this.undoStack.length > 1, // 至少有一个可撤销的操作（排除根节点）
      canRedo: this.redoStack.length > 0,
      canBacktrack: hasValidBacktrackNode, // 回溯状态中不能再次回溯
      totalNodes: this.nodeCount,
    };
  }

  printCurrentBoard(msg = ' ') {
    if (!this.currentNode) {
      console.log('当前没有游戏状态');
      return;
    }
    
    const board = this.currentNode.state.board;
    console.log(msg , '  当前棋盘状态:');
    
    for (let y = 0; y < 9; y++) {
      let row = '';
      for (let x = 0; x < 9; x++) {
        const value = board[y][x];
        row += (value === 0 ? '.' : value) + ' ';
      }
      console.log(`行 ${y}: ${row}`);
    }
    
    console.log('当前节点信息:', {
      id: this.currentNode.id,
      description: this.currentNode.state.description,
      backtrackable: this.currentNode.backtrackable,
      infos: this.currentNode.infos,
      parentId: this.currentNode.parent?.id || '无',
      childrenCount: this.currentNode.children?.length || 0,
    });
  }

  printHistoryTree() {
    console.log('历史树结构:');
    this.printNode(this.root, 0);
  }

  printNode(node, depth) {
    const indent = '  '.repeat(depth);
    const isCurrent = node === this.currentNode;
    const marker = isCurrent ? '[*]' : '[ ]';
    const backtrackMark = node.backtrackable ? '(B)' : '';
    
    console.log(`${indent}${marker} ${node.id}: ${node.state.description} ${backtrackMark}`);
    
    if (node.children) {
      node.children.forEach(child => {
        this.printNode(child, depth + 1);
      });
    }
  }
  
  pruneHistory() {
    if (this.nodeCount <= this.MAX_HISTORY) return;
    
    const leaves = this.collectLeaves(this.root);
    leaves.sort((a, b) => a.createdAt - b.createdAt);
    
    for (const leaf of leaves) {
      if (this.nodeCount <= this.MAX_HISTORY * 0.8) break;
      
      if (leaf.parent) {
        const index = leaf.parent.children.indexOf(leaf);
        if (index > -1) {
          leaf.parent.children.splice(index, 1);
          this.nodeCount--;
        }
      }
    }
  }

  collectLeaves(node) {
    if (!node.children || node.children.length === 0) {
      return [node];
    }
    
    let leaves = [];
    for (const child of node.children) {
      leaves = leaves.concat(this.collectLeaves(child));
    }
    
    return leaves;
  }
  
}
//-------------------------
let treeHistoryManagerInstance = null;

export function getTreeHistoryManager() {
  if (!treeHistoryManagerInstance) {
    treeHistoryManagerInstance = new TreeHistoryManager();
  }
  return treeHistoryManagerInstance;
}