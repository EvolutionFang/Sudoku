import { writable, get, derived } from 'svelte/store';
import { userGrid } from '@sudoku/stores/grid.js';
import { candidates } from '@sudoku/stores/candidates.js';
import { cursor } from '@sudoku/stores/cursor.js';
import { timer } from '@sudoku/stores/timer.js';
import { getCandidateSet } from '@sudoku/strategies';
import { logicalCandidates } from '@sudoku/stores/logicalCandidates.js';
import { cloneState, applyFullState } from './historyUtils';

// --- Declarations ---
const historyStack = writable([]);
const redoStack = writable([]);

export const historyStatus = derived(
    [historyStack, redoStack],
    ([$history, $redo]) => ({
        canUndo: $history.length > 1,
        canRedo: $redo.length > 0
    })
);

/**
 * Capture a complete snapshot of the current game board.
 * @param {Array} logicalCandidates - 3D array of algorithmic candidates.
 * @returns {Object} The BoardState snapshot.
 */
export function getBoardSnapshot(logicalCandidates) {
    return {
        digits: cloneState(get(userGrid)),
        candidates: cloneState(get(candidates)),
        candidates_lists: cloneState(logicalCandidates),
        cursor: cloneState(get(cursor)),
        timer: get(timer)
    };
}

/**
 * Push current state into the history stack and trigger algorithm calculation.
 * @param {string} actionLabel - Description of the action.
 * @param {Object} [currentHint=null] - Associated hint data if any.
 */
export function pushSnapshot(actionLabel, currentHint = null) {
    const currentGrid = get(userGrid);
    const logicalCandidatesList = getCandidateSet(currentGrid, ['NakedPair', 'HiddenSingle']);
    
    const node = {
        state: getBoardSnapshot(logicalCandidatesList),
        action: actionLabel,
        timestamp: Date.now(),
        hint: currentHint
    };

    historyStack.update($stack => [...$stack, node]);
    redoStack.set([]);
}

/**
 * Perform undo operation by moving the current state to the redo stack.
 * @returns {Object|null} The restored BoardState or null if at bottom.
 */
export function undo() {
    const stack = get(historyStack);
    if (stack.length <= 1) return null;

    const currentState = stack.pop();
    redoStack.update($redo => [currentState, ...$redo]);
    
    const previousNode = stack[stack.length - 1];
    applyFullState(previousNode.state);
    
    historyStack.set(stack);
    return previousNode.state;
}

/**
 * Perform redo operation by moving a state back from the redo stack.
 * @returns {Object|null} The restored BoardState or null if redo stack is empty.
 */
export function redo() {
    const rStack = get(redoStack);
    if (rStack.length === 0) return null;

    const nextStateNode = rStack.shift();
    redoStack.set(rStack);
    historyStack.update($hStack => [...$hStack, nextStateNode]);
    
    applyFullState(nextStateNode.state);
    return nextStateNode.state;
}


/**
 * Rapidly navigate through history steps.
 * @param {number} stepCount - Negative for backward, positive for forward.
 * @returns {Object|null} The final BoardState after roaming.
 */
export function MapsHistory(stepCount) {
    if (stepCount === 0) return getTopSnapshot()?.state;

    let finalState = null;
    if (stepCount < 0) {
        for (let i = 0; i < Math.abs(stepCount); i++) {
            const state = undo();
            if (!state) break;
            finalState = state;
        }
    } else {
        for (let i = 0; i < stepCount; i++) {
            const state = redo();
            if (!state) break;
            finalState = state;
        }
    }
    return finalState;
}

export function getStack() { return get(historyStack); }
export function getRedoStack() { return get(redoStack); }
export function getHistoryStatus() { return get(historyStatus); }
export function getTopSnapshot() {
    const stack = get(historyStack);
    return stack.length === 0 ? null : stack[stack.length - 1];
}
