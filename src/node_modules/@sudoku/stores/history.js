import { writable, get, derived } from 'svelte/store';
import { userGrid } from './grid';
import { candidates } from './candidates';
import { cursor } from './cursor';
import { timer } from './timer';
// import { hintClue } from './hintClue'; 
import { getCandidateSet } from '@sudoku/strategies';
import { logicalCandidates } from './logicalCandidates.js';

const historyStack = writable([]);
const redoStack = writable([]);

/**
 * 工具函数：深拷贝 BoardState
 * 确保历史记录不受后续操作影响
 */
function cloneState(state) {
    return JSON.parse(JSON.stringify(state));
}

/**
 * 接口 1: getBoardSnapshot()
 * 功能：获取当前时刻的完整盘面快照
 */
export function getBoardSnapshot(logicalCandidates) {
    return {
        digits: cloneState(get(userGrid)),          
        candidates: cloneState(get(candidates)), 
        candidates_lists: cloneState(logicalCandidates),   
        cursor: cloneState(get(cursor)),           
        timer: get(timer)                           
    };
}

/**
 * 接口 2: pushSnapshot(actionLabel)
 * 功能：将当前状态压入历史栈
 */
export function pushSnapshot(actionLabel, currentHint = null) {
    const currentGrid = get(userGrid);
    const logicalCandidates = getCandidateSet(currentGrid, ['NakedPair', 'HiddenSingle']);
    const node = {
        state: getBoardSnapshot(logicalCandidates),
        action: actionLabel,
        timestamp: Date.now(),
        hint: currentHint
    };

    historyStack.update($stack => [...$stack, node]);
    redoStack.set([]); // 新操作会清空重做栈
}

/**
 * 内部私有方法：应用快照到各个 Store
 * 确保 UI 响应式同步更新
 */
function applyFullState(boardState) {
    userGrid.setFullGrid(boardState.digits);      
    candidates.setFull(boardState.candidates); 
    cursor.set(boardState.cursor.x, boardState.cursor.y); 
    timer.set(boardState.timer);          
    logicalCandidates.set(boardState.candidates_lists); 
    
    // 清除当前的提示高亮，除非节点自带提示
    // if (!boardState.hint) {
    //     hintClue.clear();
    // } else {
    //     hintClue.set(boardState.hint);
    // }
}

/**
 * 接口 3: undo()
 * 功能：执行撤销操作
 */
export function undo() {
    const stack = get(historyStack);
    if (stack.length <= 1) return null; 

    const currentState = stack.pop();
    redoStack.update($redo => [...$redo, currentState]);
    
    const previousState = stack[stack.length - 1];
    applyFullState(previousState.state);
    
    historyStack.set(stack);
    return previousState.state;
}


/**
 * 接口 4: redo()
 * 功能：执行重做操作
 */
export function redo() {
    const rStack = get(redoStack);
    if (rStack.length === 0) return null; 

    const nextStateNode = rStack.pop();
    redoStack.set(rStack);
    historyStack.update($hStack => [...$hStack, nextStateNode]);
    applyFullState(nextStateNode.state);

    return nextStateNode.state;
}

/**
 * 接口 5: revertToRecentBranch()
 * 功能：回溯到最近的分支点（候选数 > 1 的节点）
 */
export function revertToRecentBranch() {
    const stack = get(historyStack);
    // 从后往前搜，跳过当前节点
    for (let i = stack.length - 2; i >= 0; i--) {
        const node = stack[i];
        // 检查快照中是否含有多个候选数的格子
        const hasBranch = Object.values(node.state.candidates).some(c => c.length > 1);
        
        if (hasBranch) {
            const newStack = stack.slice(0, i + 1);
            historyStack.set(newStack);
            applyFullState(node.state);
            return node.state;
        }
    }
    return null;
}

export const historyStatus = derived(
    [historyStack, redoStack],
    ([$history, $redo]) => ({
        canUndo: $history.length > 1,
        canRedo: $redo.length > 0
    })
);


/**
 * 接口 6: getStack()
 * 功能：获取当前历史栈的完整数据数组
 */
export function getStack() {
    return get(historyStack);
}

/**
 * 接口 7: getHistoryStatus()
 * 功能：用于控制 UI 按钮的启用/禁用
 */
export function getHistoryStatus() {
    return get(historyStatus);
}

/**
 * 接口 8: getRedoStack()
 * 功能：获取当前重做栈的完整数据数组
 */
export function getRedoStack() {
    return get(redoStack);
}

/**
 * 接口 9: getTopSnapshot()
 * 功能：获取历史栈栈顶的数据节点
 */
export function getTopSnapshot() {
    const stack = get(historyStack);
    if (stack.length === 0) return null;
    
    return stack[stack.length - 1];
}


/**
 * 接口 10: MapsHistory(stepCount)
 * 功能：通过复用 undo/redo 实现多步漫游
 */
export function MapsHistory(stepCount) {
    if (stepCount === 0) return getTopSnapshot()?.state;

    let finalState = null;

    if (stepCount < 0) {
        for (let i = 0; i < Math.abs(stepCount); i++) {
            const state = undo();
            if (!state) break;
            finalState = state;
        }
    } else {

        for (let i = 0; i < stepCount; i++) {
            const state = redo();
            if (!state) break; 
            finalState = state;
        }
    }

    return finalState; 
}

/**
 * 接口: setHintResult(hintResult)
 * 功能：接收线索并存储
 */
// export function setHintResult(hintResult) {
//     hintClue.set(hintResult);
// }

//用于测试
if (typeof window !== 'undefined') {
    console.log("History file loaded!");
    window.B_Debug = {
        api: {
            getBoardSnapshot,
            pushSnapshot,
            undo,
            redo,
            revertToRecentBranch,
            getHistoryStatus,
            getStack,
            getRedoStack,
            getTopSnapshot,
            MapsHistory
        },
        stores: {
            userGrid,
            candidates,
            cursor,
            timer
        },
        getValues: () => ({
            grid: get(userGrid),
            notes: get(candidates),
            cursor: get(cursor),
            status: get(historyStatus)
        }),
        printGrid: () => console.table(get(userGrid))
    };

    userGrid.subscribe(val => {
        console.log("%c[数据监控] 棋盘数字已更新:", "color: #2196F3; font-weight: bold;");
        console.table(val);
    });
}