import { cursor } from './cursor';
import { gamePaused } from './game';
import { grid } from './grid';
import { derived, writable } from 'svelte/store';
import { getCandidateSet } from '@sudoku/strategies';
import { saveUserAction } from '@sudoku/stores/treeHistoryManager';

/**
 * Derived store determining if the keyboard should be interactive.
 */
export const keyboardDisabled = derived(
	[cursor, grid, gamePaused],
	([$cursor, $grid, $gamePaused]) => {
		return ($cursor.x === null && $cursor.y === null) || $grid[$cursor.y][$cursor.x] !== 0 || $gamePaused;
	},
	false,
);

export const hintCandidates = writable([]);
export const triedCandidates = writable([]);
export const isHintActive = writable(false);

/**
 * Observer: Reset hints when the user moves the cursor.
 */
cursor.subscribe(() => resetKeyboardHints());

/**
 * Resets all hint-related states.
 */
export function resetKeyboardHints() {
	isHintActive.set(false);
	hintCandidates.set([]);
	triedCandidates.set([]);
}

/**
 * Updates keyboard hint state with candidates and previously tried numbers.
 */
export function setKeyboardHints(candidates, tried = []) {
	hintCandidates.set(candidates);
	triedCandidates.set(tried);
	isHintActive.set(true);
}

/**
 * Core business logic for handling Sudoku input actions.
 * @param {number} num - The digit to insert (0 for clear).
 * @param {Object} context - Object containing current store values and instances.
 */
export function handleKeyButton(num, { 
    $keyboardDisabled, $isHintActive, $hintCandidates, $notes, $cursor, $userGrid,
    userGrid, candidatesStore, historyTree, isInBacktrackMode 
}) {
	// 1. Validation for Hint Mode
	if ($isHintActive && num !== 0 && !$hintCandidates.includes(num)) {
		return;
	}

	if ($keyboardDisabled) return;

	if ($notes) {
		// 2. Speculative Notes Mode
		if (num === 0) {
			candidatesStore.clear($cursor);
		} else {
			candidatesStore.add($cursor, num);
		}
		userGrid.set($cursor, 0); 
	} else {
		// 3. Direct Entry Mode
		if (candidatesStore.hasNotes?.($cursor)) {
			candidatesStore.clear($cursor);
		}
		
		const total_candidates = getCandidateSet($userGrid, []);
		const cellCandidates = total_candidates[$cursor.y][$cursor.x];
		const currentNode = historyTree.getCurrentNodeInfo();
		
		// 4. Branching Logic for Backtracking
		const isSameCellDecision = isInBacktrackMode && 
            currentNode?.infos?.cell?.x === $cursor.x && 
            currentNode?.infos?.cell?.y === $cursor.y;

		if (cellCandidates?.length > 1 && (!isInBacktrackMode || !isSameCellDecision)) {
			saveUserAction($cursor, num, cellCandidates, true);
		}
		
		userGrid.set($cursor, num);
		saveUserAction($cursor, num, cellCandidates, false);
	}

	resetKeyboardHints();
}