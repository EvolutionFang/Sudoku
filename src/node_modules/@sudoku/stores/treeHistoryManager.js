import { pushSnapshot } from '@sudoku/stores/history.js';
import { applyFullState } from './historyUtils';

/**
 * A node in the backtracking history tree.
 * Each node represents a snapshot of the game state at a specific moment.
 */
export class TreeNode {
  /**
   * @param {Object} historyNode - Snapshot returned by pushSnapshot (contains state, action, timestamp).
   * @param {TreeNode|null} parent - Parent node in the history tree.
   * @param {boolean} backtrackable - Whether this node can be used as a backtracking decision point.
   * @param {Object|null} infos - Metadata for backtracking decisions.
   * @param {Object} infos.cell - Cell position {x, y}.
   * @param {number[]} infos.candidates - All possible candidates at this decision point.
   * @param {number[]} infos.tried - Candidates already tried.
   */
  constructor(historyNode, parent = null, backtrackable = false, infos = null) {
    this.id = Date.now().toString(36) + Math.random().toString(36).substr(2);
    this.historyNode = historyNode;
    this.parent = parent;
    this.children = [];
    this.backtrackable = backtrackable;
    /** Backtracking metadata (cell, candidates, tried list) */
    this.infos = infos;
  }
}

/**
 * Manager class that maintains a tree-structured history
 * for backtracking and branching gameplay states.
 */
export class TreeHistoryManager {
  constructor() {
    this.root = null;
    this.currentTreeNode = null;
    this.isInBacktrackMode = false;
    this.nodeCount = 0;
  }
  
  /**
   * Initialize a new game and create the root history node.
   * @param {string} description - Description for the initial snapshot.
   * @returns {TreeNode} The root node of the history tree.
   */
  initGame(description = 'start game') {
    const currentHistoryNode = pushSnapshot(description);

    this.root = new TreeNode(currentHistoryNode, null, false, null);
    this.currentTreeNode = this.root;
    this.nodeCount = 1;

    return this.root;
  }

  /**
   * Save the current game state as a new node in the history tree.
   * This always creates a child node of the current node.
   *
   * @param {string} description - Description of the user action.
   * @param {boolean} backtrackable - Whether this node is a backtracking decision point.
   * @param {Object|null} infos - Backtracking metadata (cell, candidates, tried).
   * @returns {TreeNode|null} The newly created tree node.
   */
  saveState(description = '', backtrackable = false, infos = null) {
    if (!this.currentTreeNode) return null;

    const currentHistoryNode = pushSnapshot(description);
    
    const newTreeNode = new TreeNode(
      currentHistoryNode,
      this.currentTreeNode,
      backtrackable,
      infos
    );
    
    this.currentTreeNode.children.push(newTreeNode);
    this.currentTreeNode = newTreeNode;
    this.nodeCount++;

    // Leaving backtracking mode once a new branch is created
    this.isInBacktrackMode = false;
    
    return newTreeNode;
  }
  
  /**
   * Perform a backtrack operation.
   * Restores the game state to the most recent backtrackable ancestor node.
   *
   * @returns {boolean} Whether backtracking was successful.
   */
  backtrack() {
    const backtrackNode = this.findLastBacktrackableNode();
    
    if (!backtrackNode) {
      console.log('have no backtrackable node....');
      return false;
    }
    
    this.isInBacktrackMode = true;

    // Restore full game state from snapshot
    applyFullState(backtrackNode.historyNode.state);

    // Move current pointer to the backtracked node
    this.currentTreeNode = backtrackNode;
    
    return true;
  }
  
  /**
   * Find the nearest ancestor node that is marked as backtrackable.
   * Traverses upward from the current node.
   *
   * @returns {TreeNode|null} The nearest backtrackable node, or null if none exists.
   */
  findLastBacktrackableNode() {
    if (!this.currentTreeNode) return null;

    let node = this.currentTreeNode.parent;
    
    while (node) {
      if (node.backtrackable) {
        return node;
      }
      node = node.parent;
    }
    
    return null;
  }

  /**
   * Record a tried candidate value for the current backtrackable node.
   * Ensures that each value is only recorded once.
   *
   * @param {number} value - Candidate value that has been tried.
   */
  addCurrentTriedCandidate(value) {
    if (this.currentTreeNode && this.currentTreeNode.backtrackable) {
      if (!this.currentTreeNode.infos.tried.includes(value)) {
        this.currentTreeNode.infos.tried.push(value);

        // Update backtrackable status based on remaining candidates
        this.currentTreeNode.backtrackable =
          this.currentTreeNode.infos.candidates.some(
            candidate => !this.currentTreeNode.infos.tried.includes(candidate)
          );
      }
    }
  }

  /**
   * Retrieve information about the next available backtracking decision.
   *
   * @returns {Object} Backtracking information for UI or control logic.
   */
  getInfos() {
    const backtrackNode = this.findLastBacktrackableNode();
    
    if (!backtrackNode || !backtrackNode.infos) {
      return {
        available: false,
        message: '没有可回溯的节点'
      };
    }
    
    const remaining =
      backtrackNode.infos.candidates.length -
      backtrackNode.infos.tried.length;
    
    return {
      available: true,
      node: backtrackNode,
      remainingCandidates: remaining,
      tried: backtrackNode.infos.tried,
      allCandidates: backtrackNode.infos.candidates,
      cell: backtrackNode.infos.cell
    };
  }

  /**
   * Aggregated status information of the history tree.
   * Used mainly for UI state binding.
   */
  get stats() {                     
    const lastBackableNode = this.findLastBacktrackableNode();  

    return {
      isInBacktrackMode: this.isInBacktrackMode,
      isBacktrackableNode: this.currentTreeNode
        ? this.currentTreeNode.backtrackable
        : false,
      totalNodes: this.nodeCount,
      canBacktrack: lastBackableNode !== null,
    };
  }

  /**
   * Whether the current node itself is backtrackable.
   *
   * @returns {boolean}
   */
  isBacktrackableNode() {
    return this.currentTreeNode
      ? this.currentTreeNode.backtrackable
      : false;
  }
}

/** Singleton instance managing the history tree */
const historyTreeManager = new TreeHistoryManager();

/**
 * Store-like interface for exposing history tree status to the UI.
 * Provides a subscribe method compatible with Svelte stores.
 */
export const historyTree = {
  /**
   * Subscribe to history tree status updates.
   * Polls internal state at a fixed interval.
   *
   * @param {Function} callback - Called with the latest status object.
   * @returns {Function} Unsubscribe function.
   */
  subscribe: (callback) => {
    const update = () => {
      const stats = historyTreeManager.stats;
      const info = historyTreeManager.getInfos();

      callback({
        ...stats,
        backtrackInfo: info
      });
    };

    // Push initial state immediately
    update();

    const interval = setInterval(update, 100);

    return () => {
      clearInterval(interval);
    };
  },

  /** Get current aggregated stats synchronously */
  getStats: () => historyTreeManager.stats,

  /** Get current backtracking information synchronously */
  getInfos: () => historyTreeManager.getInfos(),

  /** Whether the system is currently in backtracking mode */
  isInBacktrackMode: () => historyTreeManager.stats.isInBacktrackMode,

  /** Whether the current node is backtrackable */
  isBacktrackableNode: () => historyTreeManager.stats.isBacktrackableNode,

  /** Whether any backtracking is currently possible */
  canBacktrack: () => historyTreeManager.stats.canBacktrack,
};

/**
 * Initialize history tracking for a new game.
 *
 * @returns {TreeNode} Root node of the history tree.
 */
export function initGameHistory() {
  return historyTreeManager.initGame();
}

/**
 * Save a user action into the history tree.
 * Handles both normal moves and backtrackable decision points.
 *
 * @param {Object} cell - Cell position {x, y}.
 * @param {number} value - Value chosen by the user.
 * @param {number[]} cellCandidates - Candidate values for this cell.
 * @param {boolean} backtrackable - Whether this action is a backtracking decision.
 * @returns {TreeNode|null} Newly created tree node.
 */
export function saveUserAction(cell, value, cellCandidates, backtrackable) {
  const infos = {
    cell: { x: cell.x, y: cell.y },
    candidates: [...cellCandidates],
    tried: [value]
  };

  // If currently at a backtrackable node, record the tried value
  if (historyTreeManager.isBacktrackableNode()) {
    historyTreeManager.addCurrentTriedCandidate(value);
  }
  
  const description = backtrackable
    ? `可回溯节点(${cell.x}, ${cell.y})`
    : `选择 (${cell.x}, ${cell.y}) = ${value}`;

  return historyTreeManager.saveState(description, backtrackable, infos);
}

/**
 * Trigger a backtracking operation.
 *
 * @returns {boolean} Whether backtracking succeeded.
 */
export function performBacktrack() {
  return historyTreeManager.backtrack();
}
