文件夹：node_modules
生成时间：当前目录下所有 .svelte / .js 文件内容


============================================================
文件: @sudoku\constants.js
------------------------------------------------------------
   1 | export const BASE_URL = 'https://sudoku.jonasgeiler.com/';
   2 | 
   3 | export const DIFFICULTY_CUSTOM = 'custom';
   4 | export const DIFFICULTIES = {
   5 | 	veryeasy: 'Very Easy',
   6 | 	easy:     'Easy',
   7 | 	medium:   'Medium',
   8 | 	hard:     'Hard',
   9 | };
  10 | 
  11 | export const DEFAULT_SETTINGS = {
  12 | 	darkTheme:            false,
  13 | 	displayTimer:         true,
  14 | 	hintsLimited:         true,
  15 | 	hints:                5,
  16 | 	highlightCells:       true,
  17 | 	highlightSame:        true,
  18 | 	highlightConflicting: true,
  19 | };
  20 | export const MAX_HINTS = 99999;
  21 | 
  22 | export const SUDOKU_SIZE = 9;
  23 | export const BOX_SIZE = 3;
  24 | export const GRID_LENGTH = SUDOKU_SIZE * SUDOKU_SIZE;
  25 | export const GRID_COORDS = [[0,0],[0,1],[0,2],[0,3],[0,4],[0,5],[0,6],[0,7],[0,8],[1,0],[1,1],[1,2],[1,3],[1,4],[1,5],[1,6],[1,7],[1,8],[2,0],[2,1],[2,2],[2,3],[2,4],[2,5],[2,6],[2,7],[2,8],[3,0],[3,1],[3,2],[3,3],[3,4],[3,5],[3,6],[3,7],[3,8],[4,0],[4,1],[4,2],[4,3],[4,4],[4,5],[4,6],[4,7],[4,8],[5,0],[5,1],[5,2],[5,3],[5,4],[5,5],[5,6],[5,7],[5,8],[6,0],[6,1],[6,2],[6,3],[6,4],[6,5],[6,6],[6,7],[6,8],[7,0],[7,1],[7,2],[7,3],[7,4],[7,5],[7,6],[7,7],[7,8],[8,0],[8,1],[8,2],[8,3],[8,4],[8,5],[8,6],[8,7],[8,8]];
  26 | export const CANDIDATE_COORDS = [[1, 1],[1, 2],[1, 3],[2, 1],[2, 2],[2, 3],[3, 1],[3, 2],[3, 3]];
  27 | 
  28 | export const SENCODE_SEPARATOR = '-';
  29 | export const SENCODE_SEPARATOR_REVERSE = '_';
  30 | export const SENCODE_REGEX = new RegExp('^[a-zA-Z0-9]+[' + SENCODE_SEPARATOR + SENCODE_SEPARATOR_REVERSE + '][a-zA-Z0-9]+$');
  31 | 
  32 | export const BASE62_CHARSET = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
  33 | 
  34 | export const MODAL_NONE = 'none'; // Modal type when hidden
  35 | export const MODAL_DURATION = 400;
  36 | 
  37 | export const DROPDOWN_DURATION = MODAL_DURATION;
  38 | 
  39 | export const GAME_OVER_CELEBRATIONS = [
  40 | 	'Excellent!',
  41 | 	'Wow!',
  42 | 	'Congratulations!',
  43 | 	'Oh yeah!',
  44 | 	'Impressive!',
  45 | 	'Good work!',
  46 | 	'You did great!',
  47 | 	'Applause!',
  48 | 	'Great!'
  49 | ]

============================================================
文件: @sudoku\game.js
------------------------------------------------------------
   1 | import { cursor } from './stores/cursor';
   2 | import { difficulty } from './stores/difficulty';
   3 | import { gamePaused } from './stores/game';
   4 | import { grid } from './stores/grid';
   5 | import { timer } from './stores/timer';
   6 | import { hints } from './stores/hints';
   7 | import {initGameHistory} from'./stores/treeHistoryManager.js';
   8 | 
   9 | /**
  10 |  * Start new game with a generated sudoku
  11 |  *
  12 |  * @param {('veryeasy' | 'easy' | 'medium' | 'hard')} diff - Difficulty
  13 |  */
  14 | export function startNew(diff) {
  15 | 	difficulty.set(diff);
  16 | 	grid.generate(diff);
  17 | 	cursor.reset();
  18 | 	timer.reset();
  19 | 	hints.reset();
  20 | 
  21 | 	location.hash = '';
  22 | 	initGameHistory();
  23 | }
  24 | 
  25 | /**
  26 |  * Start new game with a custom sudoku
  27 |  *
  28 |  * @param {string} sencode - Sencode to decode
  29 |  */
  30 | export function startCustom(sencode) {
  31 | 	difficulty.setCustom();
  32 | 	grid.decodeSencode(sencode);
  33 | 	cursor.reset();
  34 | 	timer.reset();
  35 | 	hints.reset();
  36 | }
  37 | 
  38 | /**
  39 |  * Pause the game
  40 |  */
  41 | export function pauseGame() {
  42 | 	timer.stop();
  43 | 	gamePaused.set(true);
  44 | }
  45 | 
  46 | /**
  47 |  * Resume (un-pause) the game
  48 |  */
  49 | export function resumeGame() {
  50 | 	timer.start();
  51 | 	gamePaused.set(false);
  52 | }
  53 | 
  54 | export default {
  55 | 	startNew,
  56 | 	startCustom,
  57 | 	pause: pauseGame,
  58 | 	resume: resumeGame
  59 | };

============================================================
文件: @sudoku\strategies.js
------------------------------------------------------------
   1 | import { SUDOKU_SIZE, BOX_SIZE } from '@sudoku/constants';
   2 | 
   3 | // ==========================================
   4 | // 1. Context: Data Container & Basic Operations
   5 | // ==========================================
   6 | class SudokuContext {
   7 |     /**
   8 |      * @param {number[][]} grid - 9x9 Sudoku grid (0 represents empty)
   9 |      */
  10 |     constructor(grid) {
  11 |         this.grid = grid;
  12 |         this.candidatesMap = [];
  13 |         this._initCandidates();
  14 |     }
  15 | 
  16 |     _initCandidates() {
  17 |         // Initialize candidates: [] for filled cells, [1..9] for empty ones
  18 |         for (let r = 0; r < SUDOKU_SIZE; r++) {
  19 |             const row = [];
  20 |             for (let c = 0; c < SUDOKU_SIZE; c++) {
  21 |                 row.push(this.grid[r][c] !== 0 ? [] : [1, 2, 3, 4, 5, 6, 7, 8, 9]);
  22 |             }
  23 |             this.candidatesMap.push(row);
  24 |         }
  25 | 
  26 |         // Initial elimination based on existing numbers in the grid
  27 |         for (let r = 0; r < SUDOKU_SIZE; r++) {
  28 |             for (let c = 0; c < SUDOKU_SIZE; c++) {
  29 |                 if (this.grid[r][c] !== 0) {
  30 |                     this.removeCandidateFromRelated(r, c, this.grid[r][c]);
  31 |                 }
  32 |             }
  33 |         }
  34 |     }
  35 | 
  36 |     /**
  37 |      * Removes a specific value from the candidates of related cells (Row, Col, Box).
  38 |      */
  39 |     removeCandidateFromRelated(r, c, val) {
  40 |         let changed = false;
  41 |         const remove = (arr, v) => {
  42 |             if (!arr) return false;
  43 |             const idx = arr.indexOf(v);
  44 |             if (idx !== -1) { arr.splice(idx, 1); return true; }
  45 |             return false;
  46 |         };
  47 | 
  48 |         // Remove from Row
  49 |         for (let i = 0; i < SUDOKU_SIZE; i++) {
  50 |             if (i !== c) if (remove(this.candidatesMap[r][i], val)) changed = true;
  51 |         }
  52 |         // Remove from Col
  53 |         for (let i = 0; i < SUDOKU_SIZE; i++) {
  54 |             if (i !== r) if (remove(this.candidatesMap[i][c], val)) changed = true;
  55 |         }
  56 |         // Remove from Box
  57 |         const startRow = Math.floor(r / BOX_SIZE) * BOX_SIZE;
  58 |         const startCol = Math.floor(c / BOX_SIZE) * BOX_SIZE;
  59 |         for (let i = startRow; i < startRow + BOX_SIZE; i++) {
  60 |             for (let j = startCol; j < startCol + BOX_SIZE; j++) {
  61 |                 if (i !== r || j !== c) if (remove(this.candidatesMap[i][j], val)) changed = true;
  62 |             }
  63 |         }
  64 |         return changed;
  65 |     }
  66 | 
  67 |     getCandidates(r, c) { return this.candidatesMap[r][c]; }
  68 | 
  69 |     setCandidates(r, c, newCandidates) {
  70 |         if (this.candidatesMap[r][c].length !== newCandidates.length) {
  71 |             this.candidatesMap[r][c] = newCandidates;
  72 |             return true;
  73 |         }
  74 |         return false;
  75 |     }
  76 | }
  77 | 
  78 | // ==========================================
  79 | // 2. Strategy Base Class
  80 | // ==========================================
  81 | class Strategy {
  82 |     execute(context) { throw new Error("Implement execute()"); }
  83 | 
  84 |     getRowCells(row) { return Array.from({length:9}, (_, c) => [row, c]); }
  85 |     getColCells(col) { return Array.from({length:9}, (_, r) => [r, col]); }
  86 |     getBoxCells(boxIdx) {
  87 |         const cells = [];
  88 |         const startRow = Math.floor(boxIdx / BOX_SIZE) * BOX_SIZE;
  89 |         const startCol = (boxIdx % BOX_SIZE) * BOX_SIZE;
  90 |         for (let r = startRow; r < startRow + BOX_SIZE; r++)
  91 |             for (let c = startCol; c < startCol + BOX_SIZE; c++) cells.push([r, c]);
  92 |         return cells;
  93 |     }
  94 | }
  95 | 
  96 | // ==========================================
  97 | // 3. Concrete Strategies
  98 | // ==========================================
  99 | 
 100 | /**
 101 |  * Basic Strategy: If a cell has only one candidate, confirm it and remove it from peers.
 102 |  */
 103 | class NakedSinglePropagationStrategy extends Strategy {
 104 |     execute(context) {
 105 |         let changed = false;
 106 |         for (let r = 0; r < SUDOKU_SIZE; r++) {
 107 |             for (let c = 0; c < SUDOKU_SIZE; c++) {
 108 |                 const cands = context.getCandidates(r, c);
 109 |                 if (context.grid[r][c] === 0 && cands.length === 1) {
 110 |                     if (context.removeCandidateFromRelated(r, c, cands[0])) changed = true;
 111 |                 }
 112 |             }
 113 |         }
 114 |         return changed;
 115 |     }
 116 | }
 117 | 
 118 | /**
 119 |  * Hidden Single: If a candidate appears only once in a unit (Row/Col/Box),
 120 |  * the cell must be that value, even if it has other candidates.
 121 |  */
 122 | class HiddenSingleStrategy extends Strategy {
 123 |     execute(context) {
 124 |         let changed = false;
 125 |         const units = [{ getter: this.getRowCells }, { getter: this.getColCells }, { getter: this.getBoxCells }];
 126 |         for (const unitDef of units) {
 127 |             for (let i = 0; i < SUDOKU_SIZE; i++) {
 128 |                 const cells = unitDef.getter(i);
 129 |                 const counts = {};
 130 | 
 131 |                 // Count candidate occurrences in the unit
 132 |                 for (const [r, c] of cells) {
 133 |                     if (context.grid[r][c] === 0) {
 134 |                         for (const val of context.getCandidates(r, c)) {
 135 |                             if (!counts[val]) counts[val] = [];
 136 |                             counts[val].push([r, c]);
 137 |                         }
 138 |                     }
 139 |                 }
 140 | 
 141 |                 // If a value appears exactly once, set it as the only candidate
 142 |                 for (const val in counts) {
 143 |                     if (counts[val].length === 1) {
 144 |                         const [tR, tC] = counts[val][0];
 145 |                         if (context.getCandidates(tR, tC).length > 1) {
 146 |                             context.setCandidates(tR, tC, [parseInt(val)]);
 147 |                             changed = true;
 148 |                         }
 149 |                     }
 150 |                 }
 151 |             }
 152 |         }
 153 |         return changed;
 154 |     }
 155 | }
 156 | 
 157 | /**
 158 |  * Naked Pair: If two cells in a unit share the exact same two candidates,
 159 |  * remove these candidates from all other cells in that unit.
 160 |  */
 161 | class NakedPairStrategy extends Strategy {
 162 |     execute(context) {
 163 |         let changed = false;
 164 |         const units = [{ getter: this.getRowCells }, { getter: this.getColCells }, { getter: this.getBoxCells }];
 165 |         for (const unitDef of units) {
 166 |             for (let i = 0; i < SUDOKU_SIZE; i++) {
 167 |                 const cells = unitDef.getter(i);
 168 |                 const potential = cells.filter(([r, c]) => context.grid[r][c] === 0 && context.getCandidates(r, c).length === 2);
 169 | 
 170 |                 for (let j = 0; j < potential.length; j++) {
 171 |                     for (let k = j + 1; k < potential.length; k++) {
 172 |                         const [r1, c1] = potential[j];
 173 |                         const [r2, c2] = potential[k];
 174 |                         const cands1 = context.getCandidates(r1, c1);
 175 |                         const cands2 = context.getCandidates(r2, c2);
 176 | 
 177 |                         // Check if candidates are identical
 178 |                         if (cands1[0] === cands2[0] && cands1[1] === cands2[1]) {
 179 |                             const [v1, v2] = cands1;
 180 |                             for (const [ur, uc] of cells) {
 181 |                                 // Skip the pair itself or filled cells
 182 |                                 if ((ur === r1 && uc === c1) || (ur === r2 && uc === c2)) continue;
 183 |                                 if (context.grid[ur][uc] !== 0) continue;
 184 | 
 185 |                                 // Remove pair values from other cells
 186 |                                 const arr = context.getCandidates(ur, uc);
 187 |                                 let mod = false;
 188 |                                 if (arr.includes(v1)) { arr.splice(arr.indexOf(v1), 1); mod = true; }
 189 |                                 if (arr.includes(v2)) { arr.splice(arr.indexOf(v2), 1); mod = true; }
 190 |                                 if (mod) changed = true;
 191 |                             }
 192 |                         }
 193 |                     }
 194 |                 }
 195 |             }
 196 |         }
 197 |         return changed;
 198 |     }
 199 | }
 200 | 
 201 | // --- 新增：隐性数对 (Hidden Pair) ---
 202 | // 逻辑：如果两个数字在某个区域内（行/列/宫）只出现在两个格子里，且这两个格子完全重合，
 203 | // 那么这两个格子只能是这两个数字，可以排除这两个格子里的其他候选数。
 204 | class HiddenPairStrategy extends Strategy {
 205 |     execute(context) {
 206 |         let changed = false;
 207 |         const units = [{ getter: this.getRowCells }, { getter: this.getColCells }, { getter: this.getBoxCells }];
 208 | 
 209 |         for (const unitDef of units) {
 210 |             for (let i = 0; i < SUDOKU_SIZE; i++) {
 211 |                 const cells = unitDef.getter(i);
 212 |                 const counts = {}; // Map<number, Array<[r,c]>>
 213 | 
 214 |                 // 1. 统计每个数字出现的位置
 215 |                 for (const [r, c] of cells) {
 216 |                     if (context.grid[r][c] === 0) {
 217 |                         for (const val of context.getCandidates(r, c)) {
 218 |                             if (!counts[val]) counts[val] = [];
 219 |                             counts[val].push(`${r},${c}`);
 220 |                         }
 221 |                     }
 222 |                 }
 223 | 
 224 |                 // 2. 寻找只出现了2次的数字
 225 |                 const candidatesAppearingTwice = [];
 226 |                 for (const val in counts) {
 227 |                     if (counts[val].length === 2) {
 228 |                         candidatesAppearingTwice.push({ val: parseInt(val), positions: counts[val] });
 229 |                     }
 230 |                 }
 231 | 
 232 |                 // 3. 寻找位置完全重合的两个数字
 233 |                 for (let j = 0; j < candidatesAppearingTwice.length; j++) {
 234 |                     for (let k = j + 1; k < candidatesAppearingTwice.length; k++) {
 235 |                         const cand1 = candidatesAppearingTwice[j];
 236 |                         const cand2 = candidatesAppearingTwice[k];
 237 | 
 238 |                         // 检查位置是否相同
 239 |                         if (cand1.positions[0] === cand2.positions[0] &&
 240 |                             cand1.positions[1] === cand2.positions[1]) {
 241 | 
 242 |                             // 找到隐性数对！
 243 |                             const pos1 = cand1.positions[0].split(',').map(Number);
 244 |                             const pos2 = cand1.positions[1].split(',').map(Number);
 245 |                             const pairValues = [cand1.val, cand2.val];
 246 | 
 247 |                             // 执行排除：在这两个格子里，保留 Pair，删除其他
 248 |                             for (const [r, c] of [pos1, pos2]) {
 249 |                                 const currentCands = context.getCandidates(r, c);
 250 |                                 if (currentCands.length > 2) {
 251 |                                     // 只有当还有其他杂质时才清理
 252 |                                     const newCands = currentCands.filter(v => pairValues.includes(v));
 253 |                                     if (newCands.length !== currentCands.length) {
 254 |                                         context.setCandidates(r, c, newCands);
 255 |                                         changed = true;
 256 |                                     }
 257 |                                 }
 258 |                             }
 259 |                         }
 260 |                     }
 261 |                 }
 262 |             }
 263 |         }
 264 |         return changed;
 265 |     }
 266 | }
 267 | 
 268 | 
 269 | // ==========================================
 270 | // 4. Strategy Factory
 271 | // ==========================================
 272 | class StrategyFactory {
 273 |     constructor() {
 274 |         this.strategies = new Map();
 275 |     }
 276 | 
 277 |     register(name, strategy) {
 278 |         this.strategies.set(name, strategy);
 279 |     }
 280 | 
 281 |     getStrategy(name) {
 282 |         return this.strategies.get(name);
 283 |     }
 284 | }
 285 | 
 286 | // Initialize factory and register strategies
 287 | const strategyFactory = new StrategyFactory();
 288 | strategyFactory.register('NakedSingle', new NakedSinglePropagationStrategy());
 289 | strategyFactory.register('HiddenSingle', new HiddenSingleStrategy());
 290 | strategyFactory.register('NakedPair', new NakedPairStrategy());
 291 | strategyFactory.register('HiddenPair', new HiddenPairStrategy());
 292 | // Basic propagation strategy used in every loop
 293 | const PROPAGATION = strategyFactory.getStrategy('NakedSingle');
 294 | 
 295 | // ==========================================
 296 | // 5. Public APIs
 297 | // ==========================================
 298 | 
 299 | /**
 300 |  * Calculates the full set of candidates for the grid based on selected strategies.
 301 |  * @param {number[][]} grid - 9x9 current grid
 302 |  * @param {string[]} strategiesToUse - List of strategy names to apply
 303 |  * @returns {number[][][]} Matrix of candidate arrays
 304 |  */
 305 | export function getCandidateSet(grid, strategiesToUse = []) {
 306 |     const context = new SudokuContext(grid);
 307 |     const activeStrategies = strategiesToUse
 308 |         .map(name => strategyFactory.getStrategy(name))
 309 |         .filter(s => s);
 310 | 
 311 |     let changed = true;
 312 |     while (changed) {
 313 |         changed = false;
 314 |         // Always run basic propagation first
 315 |         if (PROPAGATION.execute(context)) { changed = true; continue; }
 316 | 
 317 |         // Run advanced strategies
 318 |         for (const s of activeStrategies) {
 319 |             if (s.execute(context)) { changed = true; break; }
 320 |         }
 321 |     }
 322 |     return context.candidatesMap;
 323 | }
 324 | 
 325 | /**
 326 |  * Validates the grid for hard conflicts and dead ends.
 327 |  * @param {number[][]} grid
 328 |  * @returns {{isValid: boolean, conflicts: Array}}
 329 |  */
 330 | export function validateGrid(grid) {
 331 |     const context = new SudokuContext(grid);
 332 |     const conflicts = [];
 333 |     let isValid = true;
 334 | 
 335 |     // 1. Check Hard Rules (Duplicates in Row/Col)
 336 |     const checkGroup = (arr, type, idx) => {
 337 |         const seen = {};
 338 |         arr.forEach((val, i) => {
 339 |             if (val !== 0) {
 340 |                 if (seen[val]) {
 341 |                     isValid = false;
 342 |                     if (type === 'row') conflicts.push([idx, i]);
 343 |                 }
 344 |                 seen[val] = true;
 345 |             }
 346 |         });
 347 |     };
 348 | 
 349 |     for (let i = 0; i < SUDOKU_SIZE; i++) {
 350 |         checkGroup(grid[i], 'row', i);
 351 |         checkGroup(grid.map(r => r[i]), 'col', i);
 352 |     }
 353 | 
 354 |     // 2. Check Dead Ends (Empty cells with 0 candidates)
 355 |     // Must run basic propagation to get accurate candidates
 356 |     PROPAGATION.execute(context);
 357 | 
 358 |     for(let r = 0; r < SUDOKU_SIZE; r++) {
 359 |         for(let c = 0; c < SUDOKU_SIZE; c++) {
 360 |             if (grid[r][c] === 0 && context.getCandidates(r, c).length === 0) {
 361 |                 isValid = false;
 362 |                 conflicts.push([r, c]);
 363 |             }
 364 |         }
 365 |     }
 366 | 
 367 |     return { isValid, conflicts };
 368 | }
 369 | 
 370 | 
 371 | export const DIFFICULTY_STRATEGIES = {
 372 |     // Very Easy: 全力辅助。开启所有策略 (包括高级的 HiddenPair)，
 373 |     // 系统会自动剔除所有可能的干扰项，候选数最少，最容易解。
 374 |     veryeasy: ['HiddenSingle', 'NakedPair', 'HiddenPair'],
 375 | 
 376 |     // Easy: 强力辅助。开启显性数对，剔除大部分干扰。
 377 |     easy:     ['HiddenSingle', 'NakedPair'],
 378 | 
 379 |     // Medium: 中等辅助。仅开启隐性唯一。
 380 |     medium:   ['HiddenSingle'],
 381 | 
 382 |     // Hard: 弱辅助。仅使用最基础的排除法 (Naked Single，基础循环自带)，
 383 |     // 不提供任何高级策略削减，候选数最多，最难判断。
 384 |     hard:     []
 385 | };
 386 | 
 387 | /**
 388 |  * 根据难度字符串获取对应的策略数组
 389 |  * @param {string} difficulty - 'veryeasy' | 'easy' | 'medium' | 'hard'
 390 |  * @returns {string[]} 策略名称数组
 391 |  */
 392 | export function getStrategiesByDifficulty(difficulty) {
 393 |     return DIFFICULTY_STRATEGIES[difficulty] || DIFFICULTY_STRATEGIES['medium'];
 394 | }

============================================================
文件: @sudoku\sudoku.js
------------------------------------------------------------
   1 | import solve from '@mattflow/sudoku-solver';
   2 | import { BOX_SIZE, GRID_LENGTH, SUDOKU_SIZE, GRID_COORDS } from '@sudoku/constants';
   3 | import { getSudoku } from 'fake-sudoku-puzzle-generator';
   4 | 
   5 | 
   6 | /**
   7 |  * @param {('veryeasy' | 'easy' | 'medium' | 'hard')} difficulty
   8 |  * @returns {number[][]}
   9 |  */
  10 | export function generateSudoku(difficulty = 'easy') {
  11 | 	const sudoku = getSudoku(difficulty);
  12 | 
  13 | 	for (let row = 0; row < SUDOKU_SIZE; row++) {
  14 | 		for (let col = 0; col < SUDOKU_SIZE; col++) {
  15 | 			if (sudoku[row][col] === null) sudoku[row][col] = 0;
  16 | 		}
  17 | 	}
  18 | 
  19 | 	return sudoku;
  20 | }
  21 | 
  22 | 
  23 | /**
  24 |  * @param {number[][]} sudoku
  25 |  */
  26 | export function solveSudoku(sudoku) {
  27 | 	let grid = [
  28 | 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
  29 | 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
  30 | 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
  31 | 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
  32 | 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
  33 | 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
  34 | 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
  35 | 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
  36 | 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
  37 | 	];
  38 | 
  39 | 	const solution = solve(sudoku.flat().join(''), {
  40 | 		outputArray: true,
  41 | 		hintCheck: false
  42 | 	});
  43 | 
  44 | 	for (let cell = 0; cell < GRID_LENGTH; cell++) {
  45 | 		const [row, col] = GRID_COORDS[cell];
  46 | 		grid[row][col] = solution[cell];
  47 | 	}
  48 | 
  49 | 	return grid;
  50 | }
  51 | 
  52 | 
  53 | /**
  54 |  * @param {number[][]} sudoku
  55 |  */
  56 | export function printSudoku(sudoku) {
  57 | 	let out = '╔═══════╤═══════╤═══════╗\n';
  58 | 
  59 | 	for (let row = 0; row < SUDOKU_SIZE; row++) {
  60 | 		if (row !== 0 && row % BOX_SIZE === 0) {
  61 | 			out += '╟───────┼───────┼───────╢\n';
  62 | 		}
  63 | 
  64 | 		for (let col = 0; col < SUDOKU_SIZE; col++) {
  65 | 			if (col === 0) {
  66 | 				out += '║ ';
  67 | 			} else if (col % BOX_SIZE === 0) {
  68 | 				out += '│ ';
  69 | 			}
  70 | 
  71 | 			out += (sudoku[row][col] === 0 ? '·' : sudoku[row][col]) + ' ';
  72 | 
  73 | 			if (col === SUDOKU_SIZE - 1) {
  74 | 				out += '║';
  75 | 			}
  76 | 		}
  77 | 
  78 | 		out += '\n';
  79 | 	}
  80 | 
  81 | 	out += '╚═══════╧═══════╧═══════╝';
  82 | 
  83 | 	console.log(out);
  84 | }

============================================================
文件: @sudoku\sencode\base62.js
------------------------------------------------------------
   1 | import { BASE62_CHARSET as CHARSET } from '@sudoku/constants';
   2 | 
   3 | export default class Base62 {
   4 | 	/**
   5 | 	 * @param {BigInt} bigInt
   6 | 	 * @returns {string}
   7 | 	 */
   8 | 	static encode(bigInt) {
   9 | 		let base = BigInt(CHARSET.length);
  10 | 		let result = '';
  11 | 
  12 | 		while (0 < bigInt) {
  13 | 			result = CHARSET.charAt(Number(bigInt % base)) + result;
  14 | 			bigInt = bigInt / base;
  15 | 		}
  16 | 
  17 | 		return result || '0';
  18 | 	}
  19 | 
  20 | 	/**
  21 | 	 * @param {string} base62
  22 | 	 * @returns {BigInt}
  23 | 	 */
  24 | 	static decode(base62) {
  25 | 		let base = BigInt(CHARSET.length);
  26 | 		let result = 0n;
  27 | 
  28 | 		for (let i = 0; i < base62.length; i++) {
  29 | 			result = result * base + BigInt(CHARSET.indexOf(base62[i]));
  30 | 		}
  31 | 
  32 | 		return result;
  33 | 	}
  34 | }

============================================================
文件: @sudoku\sencode\index.js
------------------------------------------------------------
   1 | import { GRID_COORDS, GRID_LENGTH, SENCODE_REGEX, SENCODE_SEPARATOR as SEPARATOR, SENCODE_SEPARATOR_REVERSE as SEPARATOR_REVERSE } from '@sudoku/constants';
   2 | import Base62 from './base62';
   3 | 
   4 | 
   5 | /**
   6 |  * @param {number[]} flatGrid
   7 |  * @returns {boolean}
   8 |  */
   9 | function shouldReverse(flatGrid) {
  10 | 	for (let cell = 0; cell < GRID_LENGTH; cell++) {
  11 | 		if (flatGrid[(GRID_LENGTH - 1) - cell] !== 0) {
  12 | 			return false;
  13 | 		} else if (flatGrid[cell] !== 0) {
  14 | 			return true;
  15 | 		}
  16 | 	}
  17 | 
  18 | 	return false;
  19 | }
  20 | 
  21 | 
  22 | /**
  23 |  * @param {number[][]} sudoku
  24 |  * @returns {string}
  25 |  */
  26 | export function encodeSudoku(sudoku) {
  27 | 	/** @type number[] */
  28 | 	const flatGrid = sudoku.flat();
  29 | 
  30 | 	const reversed = shouldReverse(flatGrid);
  31 | 	if (reversed) {
  32 | 		// Reverse sudoku array
  33 | 		flatGrid.reverse();
  34 | 	}
  35 | 
  36 | 	let structure = '';
  37 | 	let numbers = '';
  38 | 
  39 | 	for (let cell = 0; cell < GRID_LENGTH; cell++) {
  40 | 		structure += (flatGrid[cell] === 0 ? '0' : '1');
  41 | 
  42 | 		if (flatGrid[cell] > 0) {
  43 | 			numbers += flatGrid[cell] - 1; // Subtract 1 so the number gets smaller
  44 | 		}
  45 | 	}
  46 | 
  47 | 	return Base62.encode(BigInt('0b' + structure)) +
  48 | 	       (reversed ? SEPARATOR_REVERSE : SEPARATOR) +
  49 | 	       Base62.encode(BigInt(numbers));
  50 | }
  51 | 
  52 | 
  53 | /**
  54 |  * @param {string} sencode
  55 |  * @returns {number[][]}
  56 |  */
  57 | export function decodeSencode(sencode) {
  58 | 	let grid = [
  59 | 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
  60 | 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
  61 | 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
  62 | 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
  63 | 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
  64 | 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
  65 | 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
  66 | 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
  67 | 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
  68 | 	];
  69 | 
  70 | 	const reversed = sencode.indexOf(SEPARATOR_REVERSE) !== -1;
  71 | 
  72 | 	const [encodedStructure, encodedNumbers] = sencode.split(reversed ? SEPARATOR_REVERSE : SEPARATOR);
  73 | 
  74 | 	const structure = Base62.decode(encodedStructure)
  75 | 	                        .toString(2)
  76 | 	                        .padStart(GRID_LENGTH, '0');
  77 | 
  78 | 	let numberCount = 0;
  79 | 	for (let cell = 0; cell < GRID_LENGTH; cell++) {
  80 | 		if (structure[cell] === '1') {
  81 | 			numberCount++;
  82 | 		}
  83 | 	}
  84 | 
  85 | 	let numbers = Base62.decode(encodedNumbers)
  86 | 	                    .toString()
  87 | 	                    .padStart(numberCount, '0')
  88 | 	                    .split('');
  89 | 
  90 | 	for (let cell = 0; cell < GRID_LENGTH; cell++) {
  91 | 		if (structure[cell] === '1') {
  92 | 			const [row, col] = GRID_COORDS[cell];
  93 | 			grid[row][col] = numbers.shift() * 1 + 1;
  94 | 		}
  95 | 	}
  96 | 
  97 | 	if (reversed) {
  98 | 		// Reverse Grid
  99 | 		grid = grid.reverse().map(row => row.reverse());
 100 | 	}
 101 | 
 102 | 	return grid;
 103 | }
 104 | 
 105 | 
 106 | /**
 107 |  * @param {string} sencode
 108 |  * @returns {boolean}
 109 |  */
 110 | export function validateSencode(sencode) {
 111 | 	return sencode && sencode.trim().length !== 0 && SENCODE_REGEX.test(sencode);
 112 | }

============================================================
文件: @sudoku\stores\candidates.js
------------------------------------------------------------
   1 | import { writable } from 'svelte/store';
   2 | 
   3 | function createCandidates() {
   4 | 	const candidates = writable({});
   5 | 
   6 | 	return {
   7 | 		subscribe: candidates.subscribe,
   8 | 
   9 | 		add(pos, candidate) {
  10 | 			candidates.update($candidates => {
  11 | 				if (!$candidates.hasOwnProperty(pos.x + ',' + pos.y)) {
  12 | 					$candidates[pos.x + ',' + pos.y] = [candidate];
  13 | 				} else if ($candidates[pos.x + ',' + pos.y].includes(candidate)) {
  14 | 					delete $candidates[pos.x + ',' + pos.y][$candidates[pos.x + ',' + pos.y].indexOf(candidate)];
  15 | 				} else {
  16 | 					$candidates[pos.x + ',' + pos.y].push(candidate);
  17 | 				}
  18 | 
  19 | 				return $candidates;
  20 | 			});
  21 | 		},
  22 | 		setFull(newCandidates) {
  23 | 			candidates.set(newCandidates);
  24 | 		},
  25 | 
  26 | 		clear(pos) {
  27 | 			candidates.update($candidates => {
  28 | 				delete $candidates[pos.x + ',' + pos.y];
  29 | 				return $candidates;
  30 | 			});
  31 | 		}
  32 | 	}
  33 | }
  34 | 
  35 | export const candidates = createCandidates();

============================================================
文件: @sudoku\stores\cursor.js
------------------------------------------------------------
   1 | import { SUDOKU_SIZE } from '@sudoku/constants';
   2 | import { writable } from 'svelte/store';
   3 | 
   4 | function createCursor() {
   5 | 	const cursor = writable({ x: null, y: null });
   6 | 
   7 | 	return {
   8 | 		subscribe: cursor.subscribe,
   9 | 
  10 | 		set(x, y) {
  11 | 			cursor.set({ x, y });
  12 | 		},
  13 | 
  14 | 		move(xDir = 0, yDir = 0) {
  15 | 			cursor.update($cursor => {
  16 | 				let newX = $cursor.x + xDir;
  17 | 				let newY = $cursor.y + yDir;
  18 | 
  19 | 				if (newX < 0) newX = SUDOKU_SIZE - 1;
  20 | 				if (newX >= SUDOKU_SIZE) newX = 0;
  21 | 				if (newY < 0) newY = SUDOKU_SIZE - 1;
  22 | 				if (newY >= SUDOKU_SIZE) newY = 0;
  23 | 
  24 | 				return {
  25 | 					x: newX,
  26 | 					y: newY,
  27 | 				};
  28 | 			});
  29 | 		},
  30 | 
  31 | 		reset() {
  32 | 			this.set(null, null);
  33 | 		}
  34 | 	};
  35 | }
  36 | 
  37 | export const cursor = createCursor();

============================================================
文件: @sudoku\stores\difficulty.js
------------------------------------------------------------
   1 | import { DIFFICULTIES, DIFFICULTY_CUSTOM } from '@sudoku/constants';
   2 | import { writable } from 'svelte/store';
   3 | 
   4 | function createDifficulty() {
   5 | 	const difficulty = writable((() => {
   6 | 		const storedDifficulty = localStorage.getItem('difficulty');
   7 | 
   8 | 		if (DIFFICULTIES.hasOwnProperty(storedDifficulty)) {
   9 | 			return storedDifficulty;
  10 | 		}
  11 | 
  12 | 		return Object.keys(DIFFICULTIES)[0];
  13 | 	})());
  14 | 
  15 | 	return {
  16 | 		subscribe: difficulty.subscribe,
  17 | 
  18 | 		set(newDifficulty) {
  19 | 			if (DIFFICULTIES.hasOwnProperty(newDifficulty)) {
  20 | 				difficulty.set(newDifficulty);
  21 | 				localStorage.setItem('difficulty', newDifficulty);
  22 | 			}
  23 | 		},
  24 | 
  25 | 		setCustom() {
  26 | 			difficulty.set(DIFFICULTY_CUSTOM);
  27 | 		}
  28 | 	};
  29 | }
  30 | 
  31 | export const difficulty = createDifficulty();

============================================================
文件: @sudoku\stores\game.js
------------------------------------------------------------
   1 | import { invalidCells, userGrid } from './grid';
   2 | import { SUDOKU_SIZE } from '@sudoku/constants';
   3 | import { derived, writable } from 'svelte/store';
   4 | 
   5 | export const gamePaused = writable(true);
   6 | 
   7 | export const gameWon = derived(
   8 | 	[userGrid, invalidCells],
   9 | 	([$userGrid, $invalidCells]) => {
  10 | 		for (let row = 0; row < SUDOKU_SIZE; row++) {
  11 | 			for (let col = 0; col < SUDOKU_SIZE; col++) {
  12 | 				if ($userGrid[row][col] === 0) return false;
  13 | 			}
  14 | 		}
  15 | 		// No empty fields...
  16 | 
  17 | 		return ($invalidCells.length === 0);
  18 | 	},
  19 | 	false,
  20 | );

============================================================
文件: @sudoku\stores\grid.js
------------------------------------------------------------
   1 | import { BOX_SIZE, SUDOKU_SIZE } from '@sudoku/constants';
   2 | import { decodeSencode, encodeSudoku } from '@sudoku/sencode';
   3 | import { generateSudoku, solveSudoku } from '@sudoku/sudoku';
   4 | import { derived, writable } from 'svelte/store';
   5 | import { hints } from './hints';
   6 | 
   7 | function createGrid() {
   8 | 	const grid = writable([
   9 | 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
  10 | 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
  11 | 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
  12 | 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
  13 | 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
  14 | 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
  15 | 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
  16 | 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
  17 | 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
  18 | 	]);
  19 | 
  20 | 	return {
  21 | 		subscribe: grid.subscribe,
  22 | 
  23 | 		generate(difficulty) {
  24 | 			grid.set(generateSudoku(difficulty));
  25 | 		},
  26 | 
  27 | 		decodeSencode(sencode) {
  28 | 			grid.set(decodeSencode(sencode));
  29 | 		},
  30 | 
  31 | 		get(gridStore, x, y) {
  32 | 			return gridStore[y][x];
  33 | 		},
  34 | 
  35 | 		getSencode(gridStore) {
  36 | 			return encodeSudoku(gridStore);
  37 | 		},
  38 | 	};
  39 | }
  40 | 
  41 | export const grid = createGrid();
  42 | 
  43 | 
  44 | function createUserGrid() {
  45 | 	const userGrid = writable([
  46 | 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
  47 | 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
  48 | 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
  49 | 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
  50 | 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
  51 | 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
  52 | 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
  53 | 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
  54 | 		[0, 0, 0, 0, 0, 0, 0, 0, 0],
  55 | 	]);
  56 | 
  57 | 	grid.subscribe($grid => {
  58 | 		let newGrid = [];
  59 | 
  60 | 		for (let y = 0; y < SUDOKU_SIZE; y++) {
  61 | 			newGrid[y] = [];
  62 | 			for (let x = 0; x < SUDOKU_SIZE; x++) {
  63 | 				newGrid[y][x] = $grid[y][x];
  64 | 			}
  65 | 		}
  66 | 
  67 | 		userGrid.set(newGrid);
  68 | 	});
  69 | 
  70 | 	return {
  71 | 		subscribe: userGrid.subscribe,
  72 | 
  73 | 		set: (pos, value) => {
  74 | 			userGrid.update($userGrid => {
  75 | 				$userGrid[pos.y][pos.x] = value;
  76 | 				return $userGrid;
  77 | 			});
  78 | 		},
  79 | 
  80 | 		setFullGrid: (newGrid) => {
  81 | 			const cloned = newGrid.map(row => row.slice());
  82 |             userGrid.set(cloned);
  83 |         },
  84 | 
  85 | 		applyHint: (pos) => {
  86 | 			hints.useHint();
  87 | 			userGrid.update($userGrid => {
  88 | 				const solvedSudoku = solveSudoku($userGrid);
  89 | 				$userGrid[pos.y][pos.x] = solvedSudoku[pos.y][pos.x];
  90 | 				return $userGrid;
  91 | 			});
  92 | 		},
  93 | 	};
  94 | }
  95 | 
  96 | export const userGrid = createUserGrid();
  97 | 
  98 | export const invalidCells = derived(userGrid, $userGrid => {
  99 | 	const _invalidCells = [];
 100 | 
 101 | 	const addInvalid = (x, y) => {
 102 | 		const xy = x + ',' + y;
 103 | 		if (!_invalidCells.includes(xy)) _invalidCells.push(xy);
 104 | 	};
 105 | 
 106 | 	for (let y = 0; y < SUDOKU_SIZE; y++) {
 107 | 		for (let x = 0; x < SUDOKU_SIZE; x++) {
 108 | 
 109 | 			const value = $userGrid[y][x];
 110 | 
 111 | 			if (value) {
 112 | 				for (let i = 0; i < SUDOKU_SIZE; i++) {
 113 | 					// Check the row
 114 | 					if (i !== x && $userGrid[y][i] === value) {
 115 | 						addInvalid(x, y);
 116 | 					}
 117 | 
 118 | 					// Check the column
 119 | 					if (i !== y && $userGrid[i][x] === value) {
 120 | 						addInvalid(x, i);
 121 | 					}
 122 | 				}
 123 | 
 124 | 				// Check the box
 125 | 				const startY = Math.floor(y / BOX_SIZE) * BOX_SIZE;
 126 | 				const endY = startY + BOX_SIZE;
 127 | 				const startX = Math.floor(x / BOX_SIZE) * BOX_SIZE;
 128 | 				const endX = startX + BOX_SIZE;
 129 | 				for (let row = startY; row < endY; row++) {
 130 | 					for (let col = startX; col < endX; col++) {
 131 | 						if (row !== y && col !== x && $userGrid[row][col] === value) {
 132 | 							addInvalid(col, row);
 133 | 						}
 134 | 					}
 135 | 				}
 136 | 			}
 137 | 
 138 | 		}
 139 | 	}
 140 | 
 141 | 	return _invalidCells;
 142 | }, []);

============================================================
文件: @sudoku\stores\hints.js
------------------------------------------------------------
   1 | import { settings } from './settings';
   2 | import { writable } from 'svelte/store';
   3 | 
   4 | export const usedHints = writable(0);
   5 | 
   6 | function createHints() {
   7 | 	let defaultHints = Infinity;
   8 | 
   9 | 	const hints = writable(Infinity);
  10 | 
  11 | 	settings.subscribe(($settings) => {
  12 | 		if ($settings.hintsLimited) {
  13 | 			defaultHints = $settings.hints;
  14 | 			hints.update($hints => {
  15 | 				if ($hints > $settings.hints) return $settings.hints;
  16 | 
  17 | 				return $hints;
  18 | 			})
  19 | 		} else {
  20 | 			defaultHints = Infinity;
  21 | 			hints.set(Infinity);
  22 | 		}
  23 | 	});
  24 | 
  25 | 	return {
  26 | 		subscribe: hints.subscribe,
  27 | 
  28 | 		useHint() {
  29 | 			hints.update($hints => {
  30 | 				if ($hints > 0) {
  31 | 					usedHints.update($usedHints => $usedHints + 1);
  32 | 					return $hints - 1;
  33 | 				}
  34 | 
  35 | 				return 0;
  36 | 			});
  37 | 		},
  38 | 
  39 | 		reset() {
  40 | 			hints.set(defaultHints);
  41 | 			usedHints.set(0);
  42 | 		}
  43 | 	};
  44 | }
  45 | 
  46 | export const hints = createHints();

============================================================
文件: @sudoku\stores\history.js
------------------------------------------------------------
   1 | import { writable, get, derived } from 'svelte/store';
   2 | import { userGrid } from '@sudoku/stores/grid.js';
   3 | import { candidates } from '@sudoku/stores/candidates.js';
   4 | import { cursor } from '@sudoku/stores/cursor.js';
   5 | import { timer } from '@sudoku/stores/timer.js';
   6 | import { getCandidateSet } from '@sudoku/strategies';
   7 | import { logicalCandidates } from '@sudoku/stores/logicalCandidates.js';
   8 | import { cloneState, applyFullState } from './historyUtils';
   9 | 
  10 | // --- Declarations ---
  11 | const historyStack = writable([]);
  12 | const redoStack = writable([]);
  13 | 
  14 | export const historyStatus = derived(
  15 |     [historyStack, redoStack],
  16 |     ([$history, $redo]) => ({
  17 |         canUndo: $history.length > 1,
  18 |         canRedo: $redo.length > 0
  19 |     })
  20 | );
  21 | 
  22 | /**
  23 |  * Capture a complete snapshot of the current game board.
  24 |  * @param {Array} logicalCandidates - 3D array of algorithmic candidates.
  25 |  * @returns {Object} The BoardState snapshot.
  26 |  */
  27 | export function getBoardSnapshot(logicalCandidates) {
  28 |     return {
  29 |         digits: cloneState(get(userGrid)),
  30 |         candidates: cloneState(get(candidates)),
  31 |         candidates_lists: cloneState(logicalCandidates),
  32 |         cursor: cloneState(get(cursor)),
  33 |         timer: get(timer)
  34 |     };
  35 | }
  36 | 
  37 | /**
  38 |  * Push current state into the history stack and trigger algorithm calculation.
  39 |  * @param {string} actionLabel - Description of the action.
  40 |  * @param {Object} [currentHint=null] - Associated hint data if any.
  41 |  * @returns {Object} The created history node.
  42 |  */
  43 | export function pushSnapshot(actionLabel, currentHint = null) {
  44 |     const currentGrid = get(userGrid);
  45 |     const logicalCandidatesList = getCandidateSet(currentGrid, ['NakedPair', 'HiddenSingle']);
  46 | 
  47 |     const node = {
  48 |         state: getBoardSnapshot(logicalCandidatesList),
  49 |         action: actionLabel,
  50 |         timestamp: Date.now(),
  51 |         hint: currentHint
  52 |     };
  53 | 
  54 |     historyStack.update($stack => [...$stack, node]);
  55 |     redoStack.set([]);
  56 | 
  57 |     return node;
  58 | }
  59 | 
  60 | /**
  61 |  * Perform undo operation by moving the current state to the redo stack.
  62 |  * @returns {Object|null} The restored BoardState or null if at bottom.
  63 |  */
  64 | export function undo() {
  65 |     const stack = get(historyStack);
  66 |     if (stack.length <= 1) return null;
  67 | 
  68 |     const currentState = stack.pop();
  69 |     redoStack.update($redo => [currentState, ...$redo]);
  70 | 
  71 |     const previousNode = stack[stack.length - 1];
  72 |     applyFullState(previousNode.state);
  73 | 
  74 |     historyStack.set(stack);
  75 |     return previousNode.state;
  76 | }
  77 | 
  78 | /**
  79 |  * Perform redo operation by moving a state back from the redo stack.
  80 |  * @returns {Object|null} The restored BoardState or null if redo stack is empty.
  81 |  */
  82 | export function redo() {
  83 |     const rStack = get(redoStack);
  84 |     if (rStack.length === 0) return null;
  85 | 
  86 |     const nextStateNode = rStack.shift();
  87 |     redoStack.set(rStack);
  88 |     historyStack.update($hStack => [...$hStack, nextStateNode]);
  89 | 
  90 |     applyFullState(nextStateNode.state);
  91 |     return nextStateNode.state;
  92 | }
  93 | 
  94 | 
  95 | /**
  96 |  * Rapidly navigate through history steps.
  97 |  * @param {number} stepCount - Negative for backward, positive for forward.
  98 |  * @returns {Object|null} The final BoardState after roaming.
  99 |  */
 100 | export function MapsHistory(stepCount) {
 101 |     if (stepCount === 0) return getTopSnapshot()?.state;
 102 | 
 103 |     let finalState = null;
 104 |     if (stepCount < 0) {
 105 |         for (let i = 0; i < Math.abs(stepCount); i++) {
 106 |             const state = undo();
 107 |             if (!state) break;
 108 |             finalState = state;
 109 |         }
 110 |     } else {
 111 |         for (let i = 0; i < stepCount; i++) {
 112 |             const state = redo();
 113 |             if (!state) break;
 114 |             finalState = state;
 115 |         }
 116 |     }
 117 |     return finalState;
 118 | }
 119 | 
 120 | export function getStack() { return get(historyStack); }
 121 | export function getRedoStack() { return get(redoStack); }
 122 | export function getHistoryStatus() { return get(historyStatus); }
 123 | export function getTopSnapshot() {
 124 |     const stack = get(historyStack);
 125 |     return stack.length === 0 ? null : stack[stack.length - 1];
 126 | }

============================================================
文件: @sudoku\stores\historyUtils.js
------------------------------------------------------------
   1 | import { userGrid } from './grid';
   2 | import { candidates } from './candidates';
   3 | import { cursor } from './cursor';
   4 | import { timer } from './timer';
   5 | import { logicalCandidates } from './logicalCandidates';
   6 | 
   7 | /**
   8 |  * Deep clone the board state to ensure historical records are immutable.
   9 |  * @param {Object} state - The board state object to clone.
  10 |  * @returns {Object} A deep copy of the state.
  11 |  */
  12 | export function cloneState(state) {
  13 |     return JSON.parse(JSON.stringify(state));
  14 | }
  15 | 
  16 | /**
  17 |  * Restore all stores to a specific snapshot state.
  18 |  * @param {Object} boardState - The snapshot containing digits, candidates, etc.
  19 |  */
  20 | export function applyFullState(boardState) {
  21 |     if (!boardState) return;
  22 | 
  23 |     userGrid.setFullGrid(boardState.digits);
  24 |     candidates.setFull(boardState.candidates);
  25 |     cursor.set(boardState.cursor.x, boardState.cursor.y);
  26 |     timer.set(boardState.timer);
  27 |     logicalCandidates.set(boardState.candidates_lists);
  28 | }

============================================================
文件: @sudoku\stores\keyboard.js
------------------------------------------------------------
   1 | import { cursor } from './cursor';
   2 | import { gamePaused } from './game';
   3 | import { grid } from './grid';
   4 | import { derived, writable } from 'svelte/store';
   5 | 
   6 | // 原有的 keyboardDisabled
   7 | export const keyboardDisabled = derived(
   8 | 	[cursor, grid, gamePaused],
   9 | 	([$cursor, $grid, $gamePaused]) => {
  10 | 		return ($cursor.x === null && $cursor.y === null) || $grid[$cursor.y][$cursor.x] !== 0 || $gamePaused;
  11 | 	},
  12 | 	false,
  13 | );
  14 | 
  15 | // --- 智能提示/回溯状态 ---
  16 | 
  17 | // 当前高亮的候选数字 (例如 [1, 5, 9])
  18 | export const hintCandidates = writable([]);
  19 | 
  20 | // --- 新增：已尝试过的数字 (用于回溯后标红) ---
  21 | export const triedCandidates = writable([]);
  22 | 
  23 | // 提示模式是否激活
  24 | export const isHintActive = writable(false);
  25 | 
  26 | // 监听光标移动：一旦用户移动光标，重置
  27 | cursor.subscribe(() => {
  28 | 	resetKeyboardHints();
  29 | });
  30 | 
  31 | // 重置辅助函数
  32 | export function resetKeyboardHints() {
  33 | 	isHintActive.set(false);
  34 | 	hintCandidates.set([]);
  35 | 	triedCandidates.set([]); // 清空已尝试列表
  36 | }
  37 | 
  38 | /**
  39 |  * 设置键盘提示
  40 |  * @param {number[]} candidates - 所有合法的候选数
  41 |  * @param {number[]} tried - (可选) 已经尝试过导致失败的数字
  42 |  */
  43 | export function setKeyboardHints(candidates, tried = []) {
  44 | 	hintCandidates.set(candidates);
  45 | 	triedCandidates.set(tried);
  46 | 	isHintActive.set(true);
  47 | }

============================================================
文件: @sudoku\stores\logicalCandidates.js
------------------------------------------------------------
   1 | import { writable } from 'svelte/store';
   2 | 
   3 | function createLogicalCandidates() {
   4 |     const { subscribe, set, update } = writable([]);
   5 | 
   6 |     return {
   7 |         subscribe,
   8 |         set,
   9 |         update
  10 |     };
  11 | }
  12 | 
  13 | export const logicalCandidates = createLogicalCandidates();

============================================================
文件: @sudoku\stores\modal.js
------------------------------------------------------------
   1 | import { MODAL_DURATION, MODAL_NONE } from '@sudoku/constants';
   2 | import { writable } from 'svelte/store';
   3 | 
   4 | export const modalData = writable({});
   5 | 
   6 | function createModal() {
   7 | 	const modalType = writable(MODAL_NONE);
   8 | 
   9 | 	let onHide = false;
  10 | 	let onHideReplace = false;
  11 | 
  12 | 	return {
  13 | 		subscribe: modalType.subscribe,
  14 | 
  15 | 		show(type, data = {}) {
  16 | 			modalType.set(type);
  17 | 			modalData.set(data);
  18 | 
  19 | 			onHide = data.onHide || false;
  20 | 			onHideReplace = data.onHideReplace || false;
  21 | 		},
  22 | 
  23 | 		hide() {
  24 | 			if (onHideReplace && onHide) {
  25 | 				onHide();
  26 | 			} else {
  27 | 				modalType.set(MODAL_NONE);
  28 | 
  29 | 				if (onHide) {
  30 | 					setTimeout(onHide, MODAL_DURATION);
  31 | 				}
  32 | 			}
  33 | 		},
  34 | 	};
  35 | }
  36 | 
  37 | export const modal = createModal();

============================================================
文件: @sudoku\stores\notes.js
------------------------------------------------------------
   1 | import { writable } from 'svelte/store';
   2 | 
   3 | function createNotes() {
   4 | 	const notes = writable(false);
   5 | 
   6 | 	return {
   7 | 		subscribe: notes.subscribe,
   8 | 
   9 | 		toggle() {
  10 | 			notes.update($notes => !$notes);
  11 | 		}
  12 | 	}
  13 | }
  14 | 
  15 | export const notes = createNotes();

============================================================
文件: @sudoku\stores\settings.js
------------------------------------------------------------
   1 | import { DEFAULT_SETTINGS } from '@sudoku/constants';
   2 | import { writable } from 'svelte/store';
   3 | 
   4 | function createSettings() {
   5 | 	const settings = writable((() => {
   6 | 		const storedSettings = localStorage.getItem('settings');
   7 | 
   8 | 		if (storedSettings) {
   9 | 			return JSON.parse(storedSettings);
  10 | 		}
  11 | 
  12 | 		return DEFAULT_SETTINGS;
  13 | 	})());
  14 | 
  15 | 	return {
  16 | 		subscribe: settings.subscribe,
  17 | 
  18 | 		set(newSettings) {
  19 | 			settings.set(newSettings);
  20 | 			localStorage.setItem('settings', JSON.stringify(newSettings));
  21 | 		},
  22 | 	};
  23 | }
  24 | 
  25 | export const settings = createSettings();

============================================================
文件: @sudoku\stores\timer.js
------------------------------------------------------------
   1 | import { writable } from 'svelte/store';
   2 | 
   3 | function createTimer() {
   4 | 	let timerInterval = null;
   5 | 	let timeBegan = null;
   6 | 	let timeStopped = null;
   7 | 	let stoppedDuration = 0;
   8 | 	let running = false;
   9 | 
  10 | 	const timer = writable('00:00');
  11 | 
  12 | 	// The timer uses a writable store but only returns a subscribe function so it's read-only
  13 | 	return {
  14 | 		subscribe: timer.subscribe,
  15 | 
  16 | 		set: (value) => {
  17 |             timer.set(value);
  18 |         },
  19 | 
  20 | 		start() {
  21 | 			if (running) return;
  22 | 
  23 | 			if (timeBegan === null) {
  24 | 				this.reset();
  25 | 				timeBegan = Date.now();
  26 | 			}
  27 | 
  28 | 			if (timeStopped !== null) {
  29 | 				stoppedDuration += (Date.now() - timeStopped);
  30 | 			}
  31 | 
  32 | 			timerInterval = setInterval(() => {
  33 | 				const time = Date.now() - timeBegan - stoppedDuration;
  34 | 				const timeStr = new Date(time).toISOString().substr(11, 8);
  35 | 
  36 | 				if (timeStr.substr(0, 2) === '00') {
  37 | 					timer.set(timeStr.substr(3));
  38 | 					return;
  39 | 				}
  40 | 
  41 | 				timer.set(timeStr);
  42 | 			}, 10);
  43 | 			running = true;
  44 | 		},
  45 | 
  46 | 		stop() {
  47 | 			running = false;
  48 | 			timeStopped = Date.now();
  49 | 			clearInterval(timerInterval);
  50 | 		},
  51 | 
  52 | 		reset() {
  53 | 			running = false;
  54 | 			clearInterval(timerInterval);
  55 | 			stoppedDuration = 0;
  56 | 			timeBegan = null;
  57 | 			timeStopped = null;
  58 | 			timer.set('00:00');
  59 | 		},
  60 | 	};
  61 | }
  62 | 
  63 | export const timer = createTimer();

============================================================
文件: @sudoku\stores\treeHistoryManager.js
------------------------------------------------------------
   1 | import { pushSnapshot } from '@sudoku/stores/history.js';
   2 | import { applyFullState } from './historyUtils';
   3 | 
   4 | /**
   5 |  * A node in the backtracking history tree.
   6 |  * Each node represents a snapshot of the game state at a specific moment.
   7 |  */
   8 | export class TreeNode {
   9 |   /**
  10 |    * @param {Object} historyNode - Snapshot returned by pushSnapshot (contains state, action, timestamp).
  11 |    * @param {TreeNode|null} parent - Parent node in the history tree.
  12 |    * @param {boolean} backtrackable - Whether this node can be used as a backtracking decision point.
  13 |    * @param {Object|null} infos - Metadata for backtracking decisions.
  14 |    * @param {Object} infos.cell - Cell position {x, y}.
  15 |    * @param {number[]} infos.candidates - All possible candidates at this decision point.
  16 |    * @param {number[]} infos.tried - Candidates already tried.
  17 |    */
  18 |   constructor(historyNode, parent = null, backtrackable = false, infos = null) {
  19 |     this.id = Date.now().toString(36) + Math.random().toString(36).substr(2);
  20 |     this.historyNode = historyNode;
  21 |     this.parent = parent;
  22 |     this.children = [];
  23 |     this.backtrackable = backtrackable;
  24 |     /** Backtracking metadata (cell, candidates, tried list) */
  25 |     this.infos = infos;
  26 |   }
  27 | }
  28 | 
  29 | /**
  30 |  * Manager class that maintains a tree-structured history
  31 |  * for backtracking and branching gameplay states.
  32 |  */
  33 | export class TreeHistoryManager {
  34 |   constructor() {
  35 |     this.root = null;
  36 |     this.currentTreeNode = null;
  37 |     this.isInBacktrackMode = false;
  38 |     this.nodeCount = 0;
  39 |   }
  40 | 
  41 |   /**
  42 |    * Initialize a new game and create the root history node.
  43 |    * @param {string} description - Description for the initial snapshot.
  44 |    * @returns {TreeNode} The root node of the history tree.
  45 |    */
  46 |   initGame(description = 'start game') {
  47 |     const currentHistoryNode = pushSnapshot(description);
  48 | 
  49 |     this.root = new TreeNode(currentHistoryNode, null, false, null);
  50 |     this.currentTreeNode = this.root;
  51 |     this.nodeCount = 1;
  52 |     this.printCurrentBoard('初始化游戏，当前棋盘状态:');
  53 |     this.printHistoryTree();
  54 | 
  55 |     return this.root;
  56 |   }
  57 | 
  58 |   /**
  59 |    * Save the current game state as a new node in the history tree.
  60 |    * This always creates a child node of the current node.
  61 |    *
  62 |    * @param {string} description - Description of the user action.
  63 |    * @param {boolean} backtrackable - Whether this node is a backtracking decision point.
  64 |    * @param {Object|null} infos - Backtracking metadata (cell, candidates, tried).
  65 |    * @returns {TreeNode|null} The newly created tree node.
  66 |    */
  67 |   saveState(description = '', backtrackable = false, infos = null) {
  68 |     if (!this.currentTreeNode) return null;
  69 | 
  70 |     const currentHistoryNode = pushSnapshot(description);
  71 | 
  72 |     const newTreeNode = new TreeNode(
  73 |       currentHistoryNode,
  74 |       this.currentTreeNode,
  75 |       backtrackable,
  76 |       infos
  77 |     );
  78 | 
  79 |     this.currentTreeNode.children.push(newTreeNode);
  80 |     this.currentTreeNode = newTreeNode;
  81 |     this.nodeCount++;
  82 | 
  83 |     // Leaving backtracking mode once a new branch is created
  84 |     this.isInBacktrackMode = false;
  85 |     this.printCurrentBoard('saveState 后，当前棋盘状态:');
  86 |     this.printHistoryTree();
  87 | 
  88 |     return newTreeNode;
  89 |   }
  90 |   printCurrentBoard(msg = ' ') {
  91 |     if (!this.currentTreeNode) {
  92 |       console.log('当前没有游戏状态');
  93 |       return;
  94 |     }
  95 | 
  96 |     const board = this.currentTreeNode.historyNode.state.digits;
  97 |     console.log(msg, this.currentTreeNode.id, '  当前棋盘状态:');
  98 | 
  99 |     for (let y = 0; y < 9; y++) {
 100 |       let row = '';
 101 |       for (let x = 0; x < 9; x++) {
 102 |         const value = board[y][x];
 103 |         row += (value === 0 ? '.' : value) + ' ';
 104 |       }
 105 |       console.log(`行 ${y}: ${row}`);
 106 |     }
 107 | 
 108 |     console.log('当前节点信息:', {
 109 |       id: this.currentTreeNode.id,
 110 |       description: this.currentTreeNode.historyNode.action,
 111 |       backtrackable: this.currentTreeNode.backtrackable,
 112 |       infos: this.currentTreeNode.infos,
 113 |       parentId: this.currentTreeNode.parent?.id || '无',
 114 |       childrenCount: this.currentTreeNode.children?.length || 0,
 115 |     });
 116 |   }
 117 | 
 118 |   printHistoryTree() {
 119 |     console.log('历史树结构:');
 120 |     this.printNode(this.root, 0);
 121 |   }
 122 | 
 123 |   printNode(node, depth) {
 124 |     const indent = '  '.repeat(depth);
 125 |     const isCurrent = node === this.currentTreeNode;
 126 |     const marker = isCurrent ? '[*]' : '[ ]';
 127 |     const parentId = node.parent?.id || null;
 128 | 
 129 |     const candidatesInfo = node.backtrackable ?
 130 |       ` Candidates: [${node.infos.candidates.join(', ')}], Tried: [${node.infos.tried.join(', ')}]` :
 131 |       '';
 132 | 
 133 |     console.log(`${indent}${marker} ${node.id}: ${node.historyNode.action} ${parentId} ${candidatesInfo}`);
 134 | 
 135 |     if (node.children) {
 136 |       node.children.forEach(child => {
 137 |         this.printNode(child, depth + 1);
 138 |       });
 139 |     }
 140 |   }
 141 | 
 142 |   /**
 143 |    * Perform a backtrack operation.
 144 |    * Restores the game state to the most recent backtrackable ancestor node.
 145 |    *
 146 |    * @returns {boolean} Whether backtracking was successful.
 147 |    */
 148 |   backtrack() {
 149 |     const backtrackNode = this.findLastBacktrackableNode();
 150 | 
 151 |     if (!backtrackNode) {
 152 |       console.log('have no backtrackable node....');
 153 |       return false;
 154 |     }
 155 | 
 156 |     this.isInBacktrackMode = true;
 157 | 
 158 |     // Restore full game state from snapshot
 159 |     applyFullState(backtrackNode.historyNode.state);
 160 | 
 161 |     // Move current pointer to the backtracked node
 162 |     this.currentTreeNode = backtrackNode;
 163 | 
 164 |     return true;
 165 |   }
 166 | 
 167 |   /**
 168 |    * Find the nearest ancestor node that is marked as backtrackable.
 169 |    * Traverses upward from the current node.
 170 |    *
 171 |    * @returns {TreeNode|null} The nearest backtrackable node, or null if none exists.
 172 |    */
 173 |   findLastBacktrackableNode() {
 174 |     if (!this.currentTreeNode) return null;
 175 | 
 176 |     let node = this.currentTreeNode.parent;
 177 | 
 178 |     while (node) {
 179 |       if (node.backtrackable) {
 180 |         return node;
 181 |       }
 182 |       node = node.parent;
 183 |     }
 184 | 
 185 |     return null;
 186 |   }
 187 | 
 188 |   /**
 189 |    * Record a tried candidate value for the current backtrackable node.
 190 |    * Ensures that each value is only recorded once.
 191 |    *
 192 |    * @param {number} value - Candidate value that has been tried.
 193 |    */
 194 |   addCurrentTriedCandidate(value) {
 195 |     if (this.currentTreeNode && this.currentTreeNode.backtrackable) {
 196 |       if (!this.currentTreeNode.infos.tried.includes(value)) {
 197 |         this.currentTreeNode.infos.tried.push(value);
 198 | 
 199 |         // Update backtrackable status based on remaining candidates
 200 |         this.currentTreeNode.backtrackable =
 201 |           this.currentTreeNode.infos.candidates.some(
 202 |             candidate => !this.currentTreeNode.infos.tried.includes(candidate)
 203 |           );
 204 |       }
 205 |     }
 206 |   }
 207 | 
 208 |   /**
 209 |    * Retrieve information about the next available backtracking decision.
 210 |    *
 211 |    * @returns {Object} Backtracking information for UI or control logic.
 212 |    */
 213 |   getInfos() {
 214 |     const backtrackNode = this.findLastBacktrackableNode();
 215 | 
 216 |     if (!backtrackNode || !backtrackNode.infos) {
 217 |       return {
 218 |         available: false,
 219 |         message: '没有可回溯的节点'
 220 |       };
 221 |     }
 222 | 
 223 |     const remaining =
 224 |       backtrackNode.infos.candidates.length -
 225 |       backtrackNode.infos.tried.length;
 226 | 
 227 |     return {
 228 |       available: true,
 229 |       node: backtrackNode,
 230 |       remainingCandidates: remaining,
 231 |       tried: backtrackNode.infos.tried,
 232 |       allCandidates: backtrackNode.infos.candidates,
 233 |       cell: backtrackNode.infos.cell
 234 |     };
 235 |   }
 236 | 
 237 |   /**
 238 |    * Aggregated status information of the history tree.
 239 |    * Used mainly for UI state binding.
 240 |    */
 241 |   get stats() {
 242 |     const lastBackableNode = this.findLastBacktrackableNode();
 243 | 
 244 |     return {
 245 |       isInBacktrackMode: this.isInBacktrackMode,
 246 |       isBacktrackableNode: this.currentTreeNode
 247 |         ? this.currentTreeNode.backtrackable
 248 |         : false,
 249 |       totalNodes: this.nodeCount,
 250 |       canBacktrack: lastBackableNode !== null,
 251 |     };
 252 |   }
 253 | 
 254 |   /**
 255 |    * Whether the current node itself is backtrackable.
 256 |    *
 257 |    * @returns {boolean}
 258 |    */
 259 |   isBacktrackableNode() {
 260 |     return this.currentTreeNode
 261 |       ? this.currentTreeNode.backtrackable
 262 |       : false;
 263 |   }
 264 | 
 265 | getTriedForCell(x, y) {
 266 |     // 检查当前停留的节点是否是该格子的决策点
 267 |     if (this.currentTreeNode &&
 268 |         this.currentTreeNode.backtrackable &&
 269 |         this.currentTreeNode.infos &&
 270 |         this.currentTreeNode.infos.cell.x === x &&
 271 |         this.currentTreeNode.infos.cell.y === y) {
 272 |         return this.currentTreeNode.infos.tried || [];
 273 |     }
 274 |     return [];
 275 |   }
 276 | }
 277 | 
 278 | 
 279 | //   getCurrentNodeTriedCandidates() {
 280 | //     if (this.currentTreeNode) {
 281 | //       return this.currentTreeNode.infos.tried;
 282 | //     }
 283 | //   }
 284 | // }
 285 | 
 286 | /** Singleton instance managing the history tree */
 287 | const historyTreeManager = new TreeHistoryManager();
 288 | 
 289 | /**
 290 |  * Store-like interface for exposing history tree status to the UI.
 291 |  * Provides a subscribe method compatible with Svelte stores.
 292 |  */
 293 | export const historyTree = {
 294 |   /**
 295 |    * Subscribe to history tree status updates.
 296 |    * Polls internal state at a fixed interval.
 297 |    *
 298 |    * @param {Function} callback - Called with the latest status object.
 299 |    * @returns {Function} Unsubscribe function.
 300 |    */
 301 |   subscribe: (callback) => {
 302 |     const update = () => {
 303 |       const stats = historyTreeManager.stats;
 304 |       const info = historyTreeManager.getInfos();
 305 | 
 306 |       callback({
 307 |         ...stats,
 308 |         backtrackInfo: info
 309 |       });
 310 |     };
 311 | 
 312 |     // Push initial state immediately
 313 |     update();
 314 | 
 315 |     const interval = setInterval(update, 100);
 316 | 
 317 |     return () => {
 318 |       clearInterval(interval);
 319 |     };
 320 |   },
 321 | 
 322 |   /** Get current aggregated stats synchronously */
 323 |   getStats: () => historyTreeManager.stats,
 324 | 
 325 |   /** Get current backtracking information synchronously */
 326 |   getInfos: () => historyTreeManager.getInfos(),
 327 | 
 328 |   /** Whether the system is currently in backtracking mode */
 329 |   isInBacktrackMode: () => historyTreeManager.stats.isInBacktrackMode,
 330 | 
 331 |   /** Whether the current node is backtrackable */
 332 |   isBacktrackableNode: () => historyTreeManager.stats.isBacktrackableNode,
 333 | 
 334 |   /** Whether any backtracking is currently possible */
 335 |   canBacktrack: () => historyTreeManager.stats.canBacktrack,
 336 | 
 337 |    // --- 新增：暴露当前节点的详细信息 ---
 338 |   getCurrentNodeInfo: () => historyTreeManager.currentTreeNode,
 339 | 
 340 |   getTriedForCell: (x, y) => historyTreeManager.getTriedForCell(x, y)
 341 | };
 342 | 
 343 | /**
 344 |  * Initialize history tracking for a new game.
 345 |  *
 346 |  * @returns {TreeNode} Root node of the history tree.
 347 |  */
 348 | export function initGameHistory() {
 349 |   return historyTreeManager.initGame();
 350 | }
 351 | 
 352 | /**
 353 |  * Save a user action into the history tree.
 354 |  * Handles both normal moves and backtrackable decision points.
 355 |  *
 356 |  * @param {Object} cell - Cell position {x, y}.
 357 |  * @param {number} value - Value chosen by the user.
 358 |  * @param {number[]} cellCandidates - Candidate values for this cell.
 359 |  * @param {boolean} backtrackable - Whether this action is a backtracking decision.
 360 |  * @returns {TreeNode|null} Newly created tree node.
 361 |  */
 362 | export function saveUserAction(cell, value, cellCandidates, backtrackable) {
 363 |   const infos = {
 364 |     cell: { x: cell.x, y: cell.y },
 365 |     candidates: [...cellCandidates],
 366 |     tried: [value]
 367 |   };
 368 | 
 369 |   // If currently at a backtrackable node, record the tried value
 370 |   if (historyTreeManager.isBacktrackableNode()) {
 371 |     historyTreeManager.addCurrentTriedCandidate(value);
 372 |   }
 373 | 
 374 |   const description = backtrackable
 375 |     ? `可回溯节点(${cell.x}, ${cell.y})`
 376 |     : `选择 (${cell.x}, ${cell.y}) = ${value}`;
 377 | 
 378 |   return historyTreeManager.saveState(description, backtrackable, infos);
 379 | }
 380 | 
 381 | /**
 382 |  * Trigger a backtracking operation.
 383 |  *
 384 |  * @returns {boolean} Whether backtracking succeeded.
 385 |  */
 386 | export function performBacktrack() {
 387 |   return historyTreeManager.backtrack();
 388 | }